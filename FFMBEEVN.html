<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <title>Cập nhật Đơn hàng</title> <!-- Đã đổi tên tiêu đề -->
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; padding: 20px; font-size: 14px; }
    h1 { color: #333; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); table-layout: fixed; }
    th, td { border: 1px solid #ddd; padding: 8px 10px; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; position: relative; }
    th { background-color: #f2f2f2; font-weight: bold; position: sticky; top: 0; z-index: 2; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    #loading-message, #error-message { font-size: 1.2em; color: #555; font-style: italic; margin-top: 20px; }
    #error-message { color: red; font-weight: bold; }

    /* === CSS cho các tính năng chỉnh sửa === */
    .editable-cell { background-color: #e8f0fe; cursor: cell; }
    .editable-cell:focus { outline: 2px solid #4285f4; background-color: #fff; white-space: normal; overflow: visible; z-index: 5; } /* Thêm z-index */
    
    .editable-cell.modified {
      background-color: #fffbe6; /* Màu vàng nhạt */
      font-weight: bold;
      color: #c95e00;
    }
    
    .drag-handle { position: absolute; right: 0; bottom: 0; width: 8px; height: 8px; background-color: #4285f4; cursor: crosshair; display: none; z-index: 10; }
    .editable-cell:focus .drag-handle { display: block; }
    .drag-selection { border: 2px dotted #4285f4 !important; }

    /* === CSS cho nút và thông báo === */
    .controls { margin-top: 20px; display: flex; align-items: center; gap: 20px; }
    #send-button { background-color: #1a73e8; color: white; border: none; padding: 10px 20px; border-radius: 4px; font-size: 14px; font-weight: bold; cursor: pointer; transition: background-color 0.3s; }
    #send-button:hover { background-color: #185abc; }
    #send-button:disabled { background-color: #ccc; cursor: not-allowed; }
    #status-message { font-weight: bold; }
    .status-success { color: #1e8e3e; }
    .status-error { color: #d93025; }

    /* === CSS cho menu chuột phải (context menu) === */
    #context-menu {
        display: none;
        position: absolute;
        z-index: 1000;
        background-color: white;
        border: 1px solid #ccc;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        border-radius: 5px;
        min-width: 150px;
    }
    .context-menu-item {
        padding: 8px 12px;
        cursor: pointer;
    }
    .context-menu-item:hover {
        background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <h1>Danh sách toàn bộ đơn hàng</h1> <!-- Đã đổi tiêu đề H1 -->

  <div class="controls">
    <button id="send-button">Gửi Dữ Liệu</button>
    <div id="status-message"></div>
  </div>

  <div id="loading-message">Đang tải dữ liệu, vui lòng chờ...</div>
  <div id="error-message" style="display: none;"></div>

  <div style="overflow-x: auto;">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="context-menu">
      <div class="context-menu-item" id="revert-action">Hoàn tác thay đổi</div>
  </div>


<script>
  // ==========================================================
  // CẤU HÌNH TRUNG TÂM
  // ==========================================================
  const API_URL = "https://script.google.com/macros/s/AKfycbwqkdJyB7KGfY7yOEWzNpouDxJAAotREMtNwtQTN1uZ_22eMthIOHjN4t_OknZdjloS/exec";
  
  // Vẫn giữ lại để biết thứ tự cột, nhưng không dùng để hiển thị tên nữa
  const COLUMN_MAPPING = {
    maDonHang: 'Mã Đơn Hàng', ngayLenDon: 'Ngày Lên Đơn', tenKhachHang: 'Tên Khách Hàng', sdtKhach: 'SĐT Khách',
    diaChiGiao: 'Địa Chỉ Giao', tenSanPham: 'Tên Sản Phẩm', maVanDon: 'Mã Vận Đơn', thoiGianGiaoDuKien: 'Thời Gian Giao Dự Kiến',
    ghiChuNB: 'Ghi Chú Nội Bộ', tenSale: 'Tên Sale', nvVanDon: 'NV Vận Đơn', ketQuaCheck: 'Kết Quả Check',
    trangThaiGiaoHangNB: 'Trạng Thái Giao Hàng NB', lyDo: 'Lý Do', donViVanChuyen: 'Đơn Vị Vận Chuyển', tenLenDon: 'Tên Lên Đơn'
  };
  
  // THAY ĐỔI 3: Để trống mảng này để không ẩn cột nào cả
  const HIDDEN_COLUMNS = []; 
  
  // THAY ĐỔI 3: Không cần mảng này nữa vì tất cả các cột đều có thể chỉnh sửa
  // const EDITABLE_COLUMNS = ['maVanDon', 'ghiChuNB'];
  
  const DATE_COLUMNS = ['ngayLenDon', 'thoiGianGiaoDuKien'];

  // ==========================================================
  // LOGIC CHÍNH
  // ==========================================================
  
  function formatDateTime(isoString) {
    if (!isoString) return ''; try { const date = new Date(isoString); if (isNaN(date)) return isoString; const day = String(date.getDate()).padStart(2, '0'); const month = String(date.getMonth() + 1).padStart(2, '0'); const year = date.getFullYear(); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${day}/${month}/${year} ${hours}:${minutes}`; } catch (e) { return isoString; }
  }

  async function fetchDataAndBuildTable() {
    const loadingDiv = document.getElementById('loading-message'); const errorDiv = document.getElementById('error-message'); const table = document.getElementById('data-table'); const tableHead = table.querySelector('thead'); const tableBody = table.querySelector('tbody'); 
    try { 
        const response = await fetch(API_URL); 
        if (!response.ok) throw new Error(`Lỗi HTTP! Trạng thái: ${response.status}`); 
        
        // THAY ĐỔI 2: Lấy toàn bộ dữ liệu, không lọc theo "BEE" nữa
        const allData = await response.json(); 
        
        loadingDiv.style.display = 'none'; 
        if (allData.length === 0) { 
            errorDiv.textContent = 'Không có dữ liệu nào được tìm thấy.'; 
            errorDiv.style.display = 'block'; return; 
        } 
        
        const visibleColumns = Object.keys(COLUMN_MAPPING).filter(key => !HIDDEN_COLUMNS.includes(key)); 
        let headerRow = '<tr>'; 
        visibleColumns.forEach(key => { 
            // THAY ĐỔI 1: Hiển thị tên trường dữ liệu (key) thay vì tên tiếng Việt
            headerRow += `<th>${key}</th>`; 
        }); 
        headerRow += '</tr>'; 
        tableHead.innerHTML = headerRow; 
        tableBody.innerHTML = '';
    
        allData.forEach(rowData => {
            const rowEl = document.createElement('tr');
            // QUAN TRỌNG: Lưu mã đơn hàng làm định danh cho hàng
            rowEl.dataset.maDonHang = rowData.maDonHang; 
            
            visibleColumns.forEach(key => {
                const cellEl = document.createElement('td');
                let cellValue = rowData[key] ?? '';
                let displayValue = DATE_COLUMNS.includes(key) ? formatDateTime(cellValue) : cellValue;
                
                cellEl.textContent = displayValue;
                cellEl.dataset.columnKey = key;
                
                // THAY ĐỔI 3: Áp dụng tính năng chỉnh sửa cho TẤT CẢ các ô
                // Không cần kiểm tra `if (EDITABLE_COLUMNS.includes(key))` nữa
                cellEl.classList.add('editable-cell');
                cellEl.setAttribute('contenteditable', 'true');
                cellEl.dataset.originalValue = displayValue;
                
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                cellEl.appendChild(dragHandle);

                // Cảnh báo: Không nên sửa cột khóa chính 'maDonHang'
                if (key === 'maDonHang') {
                    cellEl.style.backgroundColor = '#ffebee'; // Màu đỏ nhạt để cảnh báo
                    cellEl.title = 'Cảnh báo: Không nên thay đổi giá trị ở cột này!';
                }

                rowEl.appendChild(cellEl);
            });
            tableBody.appendChild(rowEl);
        });
        initializeInteractiveFeatures();
    
    } catch (error) { 
        loadingDiv.style.display = 'none'; 
        errorDiv.textContent = 'Đã xảy ra lỗi khi tải dữ liệu: ' + error.message; 
        errorDiv.style.display = 'block'; 
        console.error("Lỗi chi tiết:", error); 
    }
  }
  
  // Các hàm bên dưới không cần thay đổi lớn, chỉ đảm bảo chúng hoạt động với logic mới
  // =================================================================================
  
  function initializeInteractiveFeatures() {
    const tableBody = document.getElementById('data-table').querySelector('tbody');
    const sendButton = document.getElementById('send-button');
    const contextMenu = document.getElementById('context-menu');
    const revertAction = document.getElementById('revert-action');
    let cellToRevert = null;

    tableBody.addEventListener('input', e => {
      if (e.target.isContentEditable) {
        updateCellModifiedState(e.target);
      }
    });

    tableBody.addEventListener('contextmenu', e => {
        const cell = e.target.closest('.editable-cell.modified');
        if (cell) {
            e.preventDefault();
            cellToRevert = cell;
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
        }
    });

    document.addEventListener('click', () => {
        contextMenu.style.display = 'none';
        cellToRevert = null;
    });

    revertAction.addEventListener('click', () => {
        if (cellToRevert) {
            const originalValue = cellToRevert.dataset.originalValue;
            const handle = cellToRevert.querySelector('.drag-handle');
            cellToRevert.textContent = originalValue;
            if (handle) cellToRevert.appendChild(handle);
            updateCellModifiedState(cellToRevert);
        }
    });

    sendButton.addEventListener('click', submitChanges);

    let isDragging = false; let startCell = null; let fillValue = ''; 
    tableBody.addEventListener('mousedown', (e) => { 
        if (e.target.classList.contains('drag-handle')) { 
            isDragging = true; 
            startCell = e.target.parentElement; 
            fillValue = startCell.childNodes[0].nodeValue || ''; 
            e.preventDefault(); 
            document.querySelectorAll('.drag-selection').forEach(el => el.classList.remove('drag-selection')); 
            startCell.classList.add('drag-selection'); 
        } 
    }); 
    
    tableBody.addEventListener('mouseover', (e) => { 
        if (isDragging && e.target.tagName === 'TD') { 
            const endCell = e.target; 
            if (startCell.cellIndex === endCell.cellIndex) { 
                updateDragSelection(startCell, endCell); 
            } 
        } 
    }); 
    
    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        document.querySelectorAll('.drag-selection').forEach(cell => {
          if (cell.classList.contains('editable-cell')) {
            const handle = cell.querySelector('.drag-handle');
            cell.textContent = fillValue;
            if(handle) cell.appendChild(handle);
            updateCellModifiedState(cell); 
          }
        });
        startCell = null;
      }
    });

    tableBody.addEventListener('paste', e => {
      const targetCell = e.target; 
      if (!targetCell.classList.contains('editable-cell')) return; 
      e.preventDefault(); 
      const pasteData = (e.clipboardData || window.clipboardData).getData('text'); 
      const lines = pasteData.trim().split(/\r\n|\n|\r/); 
      let currentRow = targetCell.parentElement; 
      const cellIndex = targetCell.cellIndex; 
      lines.forEach((line) => { 
        if (!currentRow) return; 
        const cellToUpdate = currentRow.cells[cellIndex]; 
        if (cellToUpdate && cellToUpdate.classList.contains('editable-cell')) { 
            const handle = cellToUpdate.querySelector('.drag-handle'); 
            cellToUpdate.textContent = line; 
            if(handle) cellToUpdate.appendChild(handle); 
            updateCellModifiedState(cellToUpdate); 
        } 
        currentRow = currentRow.nextElementSibling; 
      });
    });
  }

  function updateCellModifiedState(cell) {
    const originalValue = cell.dataset.originalValue;
    const currentValue = cell.textContent;

    if (currentValue !== originalValue) {
        cell.classList.add('modified');
        // Không thêm tooltip cho cột maDonHang để giữ lại cảnh báo gốc
        if (cell.dataset.columnKey !== 'maDonHang') {
          cell.title = `Giá trị gốc: ${originalValue}`; 
        }
    } else {
        cell.classList.remove('modified');
        if (cell.dataset.columnKey !== 'maDonHang') {
           cell.title = '';
        }
    }
  }

  function updateDragSelection(start, end) {
    document.querySelectorAll('.drag-selection').forEach(el => el.classList.remove('drag-selection')); 
    const tableRows = Array.from(document.getElementById('data-table').rows); 
    const startRowIndex = start.parentElement.rowIndex; 
    const endRowIndex = end.parentElement.rowIndex; 
    const colIndex = start.cellIndex; 
    const minRow = Math.min(startRowIndex, endRowIndex); 
    const maxRow = Math.max(startRowIndex, endRowIndex); 
    for(let i = minRow; i <= maxRow; i++) { 
        tableRows[i].cells[colIndex]?.classList.add('drag-selection'); 
    }
  }
  
  function submitChanges() {
    const sendButton = document.getElementById('send-button');
    const statusDiv = document.getElementById('status-message');
    const modifiedCells = document.querySelectorAll('.editable-cell.modified');
    if (modifiedCells.length === 0) {
      statusDiv.textContent = 'Không có thay đổi nào để gửi.';
      statusDiv.className = 'status-error';
      return;
    }
    
    // Kiểm tra xem maDonHang có bị sửa không
    const isIdModified = Array.from(modifiedCells).some(cell => cell.dataset.columnKey === 'maDonHang');
    if (isIdModified) {
        if (!confirm('Cảnh báo: Bạn đang thay đổi "maDonHang". Việc này có thể làm sai lệch dữ liệu. Bạn có chắc chắn muốn tiếp tục?')) {
            return; // Hủy nếu người dùng không đồng ý
        }
    }

    sendButton.disabled = true;
    statusDiv.textContent = `Đang gửi ${modifiedCells.length} thay đổi...`;
    statusDiv.className = '';
    const changes = Array.from(modifiedCells).map(cell => ({
      maDonHang: cell.parentElement.dataset.maDonHang, // Dùng mã đơn hàng GỐC để tìm dòng
      columnKey: cell.dataset.columnKey,
      newValue: cell.textContent
    }));
    
    google.script.run
      .withSuccessHandler(response => {
        sendButton.disabled = false;
        statusDiv.textContent = response.message;
        if (response.success) {
          statusDiv.className = 'status-success';
          // Nếu cập nhật thành công, tải lại toàn bộ bảng để đảm bảo tính nhất quán
          // Đặc biệt quan trọng nếu maDonHang bị thay đổi
          alert('Cập nhật thành công! Bảng sẽ được tải lại.');
          fetchDataAndBuildTable();
        } else {
          statusDiv.className = 'status-error';
        }
      })
      .withFailureHandler(error => {
        sendButton.disabled = false;
        statusDiv.textContent = 'Lỗi: ' + error.message;
        statusDiv.className = 'status-error';
      })
      .updateSheetData(changes);
  }

  window.addEventListener('load', fetchDataAndBuildTable);
</script>
</body>
</html>

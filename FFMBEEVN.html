<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Qu·∫£n l√Ω M√£ Tracking</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
    }
    
    h2 {
      color: #2c3e50;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    
    #connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .global-error {
      background-color: #ffecec;
      border: 1px solid #f5aca6;
      border-radius: 5px;
      padding: 15px;
      margin-bottom: 20px;
      color: #d8000c;
    }
    
    .global-error button {
      margin-right: 10px;
      margin-top: 10px;
      padding: 5px 15px;
      cursor: pointer;
    }
    
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: left;
    }
    
    th {
      background-color: #f8f8f8;
      font-weight: bold;
    }
    
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    input[type="text"] {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    button {
      padding: 8px 16px;
      background-color: #4285f4;
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #3367d6;
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .status {
      margin-left: 10px;
      font-weight: bold;
    }
    
    .success {
      color: #28a745;
    }
    
    .error {
      color: #dc3545;
    }
    
    .loading {
      color: #17a2b8;
    }
    
    .retry-button {
      background-color: #ffc107;
      color: #212529;
    }
    
    .retry-button:hover {
      background-color: #e0a800;
    }
    
    #loading-indicator {
      display: none;
      text-align: center;
      padding: 20px;
      color: #6c757d;
    }
    
    .offline-notice {
      background-color: #fff3cd;
      border: 1px solid #ffeeba;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 20px;
      display: none;
    }
    
    .debug-info {
      background-color: #e9ecef;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 10px;
      margin-top: 10px;
      font-family: monospace;
      font-size: 12px;
      display: none;
    }
  </style>
</head>
<body>
  <div id="connection-status">üü¢ ƒêang ki·ªÉm tra k·∫øt n·ªëi...</div>
  
  <div class="offline-notice" id="offline-notice">
    ‚ö†Ô∏è B·∫°n ƒëang ·ªü ch·∫ø ƒë·ªô offline. M·ªôt s·ªë t√≠nh nƒÉng c√≥ th·ªÉ kh√¥ng kh·∫£ d·ª•ng.
    <button onclick="location.reload()">T·∫£i l·∫°i trang</button>
  </div>
  
  <div id="global-error-container"></div>
  
  <h2>Danh s√°ch ƒë∆°n h√†ng - C·∫≠p nh·∫≠t m√£ Tracking</h2>
  
  <div>
    <button onclick="toggleDebug()">Toggle Debug</button>
    <div id="debug-info" class="debug-info"></div>
  </div>
  
  <div id="loading-indicator">
    <p>ƒêang t·∫£i d·ªØ li·ªáu...</p>
    <progress></progress>
  </div>
  
  <table id="data-table">
    <thead>
      <tr>
        <th>M√£ ƒë∆°n h√†ng</th>
        <th>M√£ Tracking</th>
        <th>H√†nh ƒë·ªông</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td colspan="3">Vui l√≤ng ch·ªù trong khi h·ªá th·ªëng t·∫£i d·ªØ li·ªáu...</td>
      </tr>
    </tbody>
  </table>

  <script>
    // C·∫•u h√¨nh
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwTmGvWMWX4R8pdHdOL_dZUyAVWipY5PTtN9GHGfujAJ4GwEDxR-V6TZAXtslm2podvTw/exec";
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 2000;
    const CACHE_KEY = 'tracking-data-cache';
    let debugMode = false;
    
    // Debug function
    function toggleDebug() {
      debugMode = !debugMode;
      const debugEl = document.getElementById('debug-info');
      debugEl.style.display = debugMode ? 'block' : 'none';
    }
    
    function debug(message, data = null) {
      if (!debugMode) return;
      const debugEl = document.getElementById('debug-info');
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `[${timestamp}] ${message}`;
      if (data) {
        debugEl.innerHTML += logEntry + '\n' + JSON.stringify(data, null, 2) + '\n\n';
      } else {
        debugEl.innerHTML += logEntry + '\n\n';
      }
      debugEl.scrollTop = debugEl.scrollHeight;
    }
    
    // Kh·ªüi t·∫°o ·ª©ng d·ª•ng - simplified
    document.addEventListener('DOMContentLoaded', async function() {
      try {
        debug("Kh·ªüi t·∫°o ·ª©ng d·ª•ng");
        
        // ƒê∆°n gi·∫£n h√≥a - skip connection check, load data tr·ª±c ti·∫øp
        updateConnectionStatus(true);
        await loadAndRenderData();
        
        // Thi·∫øt l·∫≠p monitoring
        setupConnectionMonitoring();
        
      } catch (error) {
        console.error("Kh·ªüi t·∫°o ·ª©ng d·ª•ng th·∫•t b·∫°i:", error);
        debug("Kh·ªüi t·∫°o th·∫•t b·∫°i", error);
        showErrorToUser("Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu: " + error.message);
        
        // Th·ª≠ load cached data
        loadCachedData();
      }
    });
    
    // ========== C√ÅC H√ÄM CH√çNH ========== //
    
    // Ki·ªÉm tra k·∫øt n·ªëi server ƒë∆°n gi·∫£n
    async function checkServerConnection() {
      try {
        debug("Checking server connection with simple fetch...");
        
        // Th·ª≠ fetch ƒë∆°n gi·∫£n, b·ªè qua CORS error
        const response = await fetch(GAS_URL, {
          method: 'GET',
          cache: 'no-store'
        });
        
        debug(`Response status: ${response.status}`);
        return response.status === 200;
        
      } catch (error) {
        debug("Fetch failed, but this might be normal due to CORS", error);
        // V·ªõi GAS, CORS error l√† b√¨nh th∆∞·ªùng, v·∫´n coi nh∆∞ k·∫øt n·ªëi OK
        return true;
      }
    }
    
    // Load data using JSONP method - fixed version
    function loadDataViaJSONP() {
      return new Promise((resolve, reject) => {
        const callbackName = 'jsonp_callback_' + Math.random().toString(36).substr(2, 9);
        const script = document.createElement('script');
        let resolved = false;
        
        // T·∫°o callback function
        window[callbackName] = function(data) {
          if (resolved) return;
          resolved = true;
          debug("JSONP callback received", data);
          cleanup();
          resolve(data);
        };
        
        // Cleanup function
        function cleanup() {
          if (window[callbackName]) {
            delete window[callbackName];
          }
          if (script.parentNode) {
            script.parentNode.removeChild(script);
          }
        }
        
        // Error handling
        script.onerror = function() {
          if (resolved) return;
          resolved = true;
          debug("JSONP script error");
          cleanup();
          reject(new Error('JSONP script load error'));
        };
        
        // Timeout
        const timeout = setTimeout(() => {
          if (resolved) return;
          resolved = true;
          debug("JSONP timeout");
          cleanup();
          reject(new Error('JSONP request timeout'));
        }, 8000);
        
        // Clear timeout when done
        const originalCallback = window[callbackName];
        window[callbackName] = function(data) {
          clearTimeout(timeout);
          originalCallback(data);
        };
        
        // T·∫°o URL v·ªõi callback parameter
        const url = `${GAS_URL}?callback=${callbackName}&_=${Date.now()}`;
        debug("Loading JSONP from:", url);
        
        script.src = url;
        document.head.appendChild(script);
      });
    }
    
    // C·∫≠p nh·∫≠t tr·∫°ng th√°i k·∫øt n·ªëi
    function updateConnectionStatus(isConnected) {
      const statusElement = document.getElementById('connection-status');
      if (statusElement) {
        statusElement.textContent = isConnected ? "üü¢ ƒê√£ k·∫øt n·ªëi" : "üî¥ M·∫•t k·∫øt n·ªëi";
        statusElement.style.color = isConnected ? "green" : "red";
      }
    }
    
    // Hi·ªÉn th·ªã th√¥ng b√°o offline
    function showOfflineNotice() {
      const notice = document.getElementById('offline-notice');
      if (notice) notice.style.display = 'block';
      updateConnectionStatus(false);
    }
    
    // T·∫£i v√† hi·ªÉn th·ªã d·ªØ li·ªáu v·ªõi c∆° ch·∫ø retry
    async function loadAndRenderData() {
      showLoading(true);
      debug("B·∫Øt ƒë·∫ßu t·∫£i d·ªØ li·ªáu");
      
      try {
        const data = await fetchWithRetry(GAS_URL, MAX_RETRIES, RETRY_DELAY);
        debug("D·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c", data);
        renderData(data);
        saveToCache(data);
      } catch (error) {
        console.error("T·∫£i d·ªØ li·ªáu th·∫•t b·∫°i sau nhi·ªÅu l·∫ßn th·ª≠:", error);
        debug("T·∫£i d·ªØ li·ªáu th·∫•t b·∫°i", error);
        throw error;
      } finally {
        showLoading(false);
      }
    }
    
    // H√†m fetch ƒë∆°n gi·∫£n v·ªõi JSONP
    async function fetchWithRetry(url, retries, delay) {
      for (let i = 0; i < retries; i++) {
        try {
          debug(`Th·ª≠ t·∫£i d·ªØ li·ªáu l·∫ßn ${i + 1} v·ªõi JSONP`);
          
          const data = await loadDataViaJSONP();
          debug("JSONP data loaded successfully", data);
          
          // X·ª≠ l√Ω response
          if (Array.isArray(data)) {
            return data;
          } else if (data.data && Array.isArray(data.data)) {
            return data.data;
          } else if (data.status === "error") {
            throw new Error(data.message || "L·ªói server");
          }
          
          return data;
          
        } catch (error) {
          debug(`JSONP attempt ${i + 1} failed`, error);
          
          // N·∫øu JSONP th·∫•t b·∫°i, th·ª≠ iframe method
          if (i === retries - 1) {
            debug("All JSONP attempts failed, trying iframe method");
            try {
              return await loadDataViaIframe();
            } catch (iframeError) {
              debug("Iframe method also failed", iframeError);
              throw new Error("Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu t·ª´ server");
            }
          }
          
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    // Load data via iframe as fallback
    function loadDataViaIframe() {
      return new Promise((resolve, reject) => {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.src = GAS_URL;
        
        let resolved = false;
        
        iframe.onload = function() {
          if (resolved) return;
          resolved = true;
          
          try {
            const content = iframe.contentDocument.body.textContent;
            debug("Iframe content received", content);
            
            const data = JSON.parse(content);
            cleanup();
            resolve(data);
          } catch (e) {
            debug("Iframe content parse error", e);
            cleanup();
            reject(new Error('Kh√¥ng th·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ server'));
          }
        };
        
        iframe.onerror = function() {
          if (resolved) return;
          resolved = true;
          cleanup();
          reject(new Error('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu'));
        };
        
        function cleanup() {
          setTimeout(() => {
            if (document.body.contains(iframe)) {
              document.body.removeChild(iframe);
            }
          }, 100);
        }
        
        document.body.appendChild(iframe);
        
        // Timeout
        setTimeout(() => {
          if (!resolved) {
            resolved = true;
            cleanup();
            reject(new Error('H·∫øt th·ªùi gian ch·ªù'));
          }
        }, 10000);
      });
    }
    
    // Alternative method using form submit for CORS bypass
    async function fetchViaForm(url) {
      return new Promise((resolve, reject) => {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        
        const form = document.createElement('form');
        form.method = 'GET';
        form.action = url;
        form.target = iframe.name = 'temp_frame_' + Date.now();
        
        iframe.onload = function() {
          try {
            const content = iframe.contentDocument.body.textContent;
            const data = JSON.parse(content);
            resolve(data);
          } catch (e) {
            reject(new Error('Failed to parse response'));
          } finally {
            document.body.removeChild(iframe);
          }
        };
        
        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);
        
        // Timeout
        setTimeout(() => {
          if (document.body.contains(iframe)) {
            document.body.removeChild(iframe);
            reject(new Error('Request timeout'));
          }
        }, 15000);
      });
    }
    
    // Hi·ªÉn th·ªã d·ªØ li·ªáu l√™n b·∫£ng
    function renderData(data) {
      const tbody = document.querySelector("#data-table tbody");
      debug("Rendering data", data);
      
      if (!data || data.length === 0) {
        tbody.innerHTML = `<tr><td colspan="3" style="color:gray;">Kh√¥ng c√≥ d·ªØ li·ªáu</td></tr>`;
        return;
      }
      
      tbody.innerHTML = data.map((row, index) => `
        <tr>
          <td>${escapeHtml(row.maDonHang || '')}</td>
          <td><input type="text" value="${escapeHtml(row.maTracking || '')}" id="tracking-${index}"></td>
          <td>
            <button onclick="updateRow('${escapeHtml(row.maDonHang || '')}', ${index})" id="btn-${index}">C·∫≠p nh·∫≠t</button>
            <span class="status" id="status-${index}"></span>
          </td>
        </tr>
      `).join('');
    }
    
    // C·∫≠p nh·∫≠t d√≤ng d·ªØ li·ªáu v·ªõi form submit
    async function updateRow(maDonHang, index) {
      debug(`C·∫≠p nh·∫≠t d√≤ng: ${maDonHang}, index: ${index}`);
      
      const maTracking = document.getElementById(`tracking-${index}`).value;
      const statusEl = document.getElementById(`status-${index}`);
      const buttonEl = document.getElementById(`btn-${index}`);
      
      statusEl.textContent = "ƒêang g·ª≠i...";
      statusEl.className = "status loading";
      buttonEl.disabled = true;
      
      try {
        if (!navigator.onLine) {
          throw new Error("B·∫°n ƒëang offline. Vui l√≤ng k·∫øt n·ªëi m·∫°ng ƒë·ªÉ c·∫≠p nh·∫≠t.");
        }
        
        debug("Sending update", { maDonHang, maTracking });
        
        // S·ª≠ d·ª•ng form submit ƒë∆°n gi·∫£n
        const result = await submitUpdateForm(maDonHang, maTracking);
        debug("Update result", result);
        
        if (result.status === "error") {
          throw new Error(result.message || "L·ªói t·ª´ server");
        }
        
        statusEl.textContent = result.message || "‚úî ƒê√£ c·∫≠p nh·∫≠t th√†nh c√¥ng";
        statusEl.className = "status success";
        
        // C·∫≠p nh·∫≠t cache
        updateCache(maDonHang, maTracking);
        
      } catch (error) {
        debug("Update error", error);
        console.error("L·ªói khi c·∫≠p nh·∫≠t:", error);
        statusEl.textContent = error.message || "L·ªói khi k·∫øt n·ªëi server";
        statusEl.className = "status error";
      } finally {
        buttonEl.disabled = false;
      }
    }
    
    // Submit update form
    function submitUpdateForm(maDonHang, maTracking) {
      return new Promise((resolve, reject) => {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.name = 'update_frame_' + Date.now();
        document.body.appendChild(iframe);
        
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = GAS_URL;
        form.target = iframe.name;
        
        // T·∫°o input fields
        const inputMaDonHang = document.createElement('input');
        inputMaDonHang.type = 'hidden';
        inputMaDonHang.name = 'maDonHang';
        inputMaDonHang.value = maDonHang;
        form.appendChild(inputMaDonHang);
        
        const inputMaTracking = document.createElement('input');
        inputMaTracking.type = 'hidden';
        inputMaTracking.name = 'maTracking';
        inputMaTracking.value = maTracking;
        form.appendChild(inputMaTracking);
        
        let responseReceived = false;
        
        iframe.onload = function() {
          if (responseReceived) return;
          responseReceived = true;
          
          try {
            const content = iframe.contentDocument.body.textContent;
            debug("Form submit response", content);
            const result = JSON.parse(content);
            cleanup();
            resolve(result);
          } catch (e) {
            debug("Form submit parse error", e);
            cleanup();
            reject(new Error('Kh√¥ng th·ªÉ ph√¢n t√≠ch ph·∫£n h·ªìi t·ª´ server'));
          }
        };
        
        function cleanup() {
          setTimeout(() => {
            if (document.body.contains(iframe)) {
              document.body.removeChild(iframe);
            }
            if (document.body.contains(form)) {
              document.body.removeChild(form);
            }
          }, 100);
        }
        
        // Timeout
        setTimeout(() => {
          if (!responseReceived) {
            responseReceived = true;
            cleanup();
            reject(new Error('H·∫øt th·ªùi gian ch·ªù'));
          }
        }, 15000);
        
        document.body.appendChild(form);
        form.submit();
      });
    }
    
    // ========== C√ÅC H√ÄM H·ªñ TR·ª¢ ========== //
    
    // Escape HTML ƒë·ªÉ ph√≤ng ch·ªëng XSS
    function escapeHtml(unsafe) {
      if (typeof unsafe !== 'string') return unsafe;
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
    
    // Hi·ªÉn th·ªã loading indicator
    function showLoading(show) {
      const loader = document.getElementById('loading-indicator');
      if (loader) loader.style.display = show ? 'block' : 'none';
    }
    
    // Hi·ªÉn th·ªã l·ªói to√†n c·ª•c
    function showErrorToUser(message) {
      const container = document.getElementById('global-error-container');
      if (!container) return;
      
      container.innerHTML = `
        <div class="global-error">
          <p>‚ö†Ô∏è ${escapeHtml(message)}</p>
          <button onclick="location.reload()">T·∫£i l·∫°i trang</button>
          <button class="retry-button" onclick="retryLoading()">Th·ª≠ l·∫°i</button>
        </div>
      `;
    }
    
    // Th·ª≠ t·∫£i l·∫°i d·ªØ li·ªáu
    async function retryLoading() {
      try {
        document.getElementById('global-error-container').innerHTML = '';
        await loadAndRenderData();
      } catch (error) {
        showErrorToUser("V·∫´n kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng.");
      }
    }
    
    // Thi·∫øt l·∫≠p ki·ªÉm tra k·∫øt n·ªëi ƒë·ªãnh k·ª≥
    function setupConnectionMonitoring() {
      // Ki·ªÉm tra khi tr·∫°ng th√°i m·∫°ng thay ƒë·ªïi
      window.addEventListener('online', handleNetworkChange);
      window.addEventListener('offline', handleNetworkChange);
      
      // Ki·ªÉm tra ƒë·ªãnh k·ª≥ m·ªói 30s
      setInterval(async () => {
        const isConnected = await checkServerConnection();
        updateConnectionStatus(isConnected);
      }, 30000);
    }
    
    // X·ª≠ l√Ω khi tr·∫°ng th√°i m·∫°ng thay ƒë·ªïi
    function handleNetworkChange() {
      if (navigator.onLine) {
        document.getElementById('offline-notice').style.display = 'none';
        checkServerConnection().then(isConnected => {
          updateConnectionStatus(isConnected);
          if (isConnected) retryLoading();
        });
      } else {
        showOfflineNotice();
      }
    }
    
    // ========== C√ÅC H√ÄM QU·∫¢N L√ù CACHE ========== //
    
    // L∆∞u d·ªØ li·ªáu v√†o cache (s·ª≠ d·ª•ng bi·∫øn thay v√¨ localStorage)
    let dataCache = null;
    
    function saveToCache(data) {
      try {
        dataCache = {
          data: data,
          timestamp: new Date().getTime()
        };
        debug("Data saved to cache", dataCache);
      } catch (error) {
        console.error("L·ªói khi l∆∞u cache:", error);
      }
    }
    
    // T·∫£i d·ªØ li·ªáu t·ª´ cache
    function loadCachedData() {
      try {
        if (dataCache && dataCache.data) {
          renderData(dataCache.data);
          showErrorToUser("ƒêang hi·ªÉn th·ªã d·ªØ li·ªáu t·ª´ b·ªô nh·ªõ t·∫°m. D·ªØ li·ªáu c√≥ th·ªÉ kh√¥ng c·∫≠p nh·∫≠t.");
          debug("Loaded cached data", dataCache);
        }
      } catch (error) {
        console.error("L·ªói khi t·∫£i cache:", error);
      }
    }
    
    // C·∫≠p nh·∫≠t cache khi thay ƒë·ªïi d·ªØ li·ªáu
    function updateCache(maDonHang, maTracking) {
      try {
        if (dataCache && dataCache.data) {
          const updatedData = dataCache.data.map(item => {
            if (item.maDonHang === maDonHang) {
              return { ...item, maTracking };
            }
            return item;
          });
          saveToCache(updatedData);
          debug("Cache updated", { maDonHang, maTracking });
        }
      } catch (error) {
        console.error("L·ªói khi c·∫≠p nh·∫≠t cache:", error);
      }
    }
  </script>
</body>
</html>



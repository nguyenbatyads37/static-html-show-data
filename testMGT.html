<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>Quản lý đơn hàng SPEEGO</title>
    <style>
        :root {
            --filter-row-height: 38px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
            margin: 0;
            user-select: none;
        }

        h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .main-filters {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }

        .filter-group select,
        .filter-group input {
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
        }

        /* Thêm style cho dropdown trong bảng */
        td select.editable-select {
            width: 100%;
            border: none;
            background: transparent;
            font-family: inherit;
            font-size: inherit;
            padding: 0;
            margin: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        td.editable-dropdown-cell {
            padding: 0;
            /* Xóa padding của td để select chiếm toàn bộ */
        }

        td.editable-dropdown-cell select.editable-select {
            padding: 8px 12px;
            /* Di chuyển padding vào select */
        }

        .tab-container {
            margin-bottom: 15px;
            padding: 5px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tab-btn {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .tab-btn:hover {
            background-color: #dfe6e9;
        }

        .tab-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
            font-weight: bold;
        }

        .tab-btn.tracking-tab {
            background-color: #e74c3c;
            color: white;
        }

        .tab-btn.tracking-tab.active {
            background-color: #c0392b;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            align-items: center;
            background: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .controls>div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-wrapper {
            position: relative;
            overflow: auto;
            max-height: 65vh;
            background: white;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        table {
            border-collapse: collapse;
            width: 100%;
            min-width: 1900px;
            font-size: 14px;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th,
        td {
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            text-align: left;
            white-space: nowrap;
            background-color: white;
            position: relative;
        }

        th {
            background-color: #3498db;
            color: white;
            position: sticky;
            top: var(--filter-row-height);
            z-index: 20;
            font-weight: 500;
        }

        #filterRow th {
            top: 0;
            background-color: #f2f6fa;
            padding: 4px 8px;
        }

        .filter-input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 13px;
        }

        .dual-filter-container {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .dual-filter-container input {
            flex: 1;
            min-width: 0;
        }

        td.editable {
            background-color: #fffbe8;
        }

        button {
            padding: 6px 12px;
            cursor: pointer;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        #downloadExcel {
            background-color: #16a085;
        }

        #downloadExcel:hover {
            background-color: #1abc9c;
        }

        #updateAll {
            position: relative;
        }

        .highlight {
            background-color: #ffeb3b !important;
        }

        .no-data {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-style: italic;
        }

        .refresh-btn {
            background-color: #2ecc71;
        }

        .refresh-btn:hover {
            background-color: #27ae60;
        }

        .refresh-icon {
            margin-right: 5px;
        }

        .fixed-column {
            position: sticky;
            z-index: 5;
            background-color: #f8f9fa;
            /* slightly different bg for fixed columns */
        }

        th.fixed-column {
            z-index: 30;
            background-color: #3498db;
        }

        #filterRow th.fixed-column {
            z-index: 40;
            background-color: #e9ecef;
            /* slightly different bg for fixed filter columns */
        }

        td.fixed-column {
            background-color: white;
        }

        .date-input {
            border: none;
            background: transparent;
            width: 'fit-content';
            font-family: inherit;
            font-size: inherit;
            user-select: text;
        }

        .note-highlight {
            background-color: #fff2a8;
        }

        .status-ok {
            background-color: #d4edda;
            color: #155724;
            font-weight: bold;
        }

        .status-cancel {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }

        td.cell-selected {
            background-color: rgba(52, 152, 219, 0.4) !important;
        }

        td.paste-anchor {
            outline: 2px solid #e74c3c !important;
            outline-offset: -2px;
        }

        .order-counter {
            margin-left: 15px;
            font-weight: bold;
            font-size: 14px;
            color: #2c3e50;
        }

        .order-counter b {
            color: #e74c3c;
            font-size: 16px;
            padding: 0 4px;
        }

        .selection-summary {
            margin-left: 20px;
            font-size: 14px;
            color: #2980b9;
            font-weight: 500;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .selection-summary .summary-item {
            display: inline-block;
            background-color: #ecf0f1;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
        }

        .selection-summary b {
            color: #c0392b;
            padding-left: 5px;
        }

        /* Thay thế custom alert styles bằng toast styles */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            pointer-events: none;
        }

        .toast {
            background: white;
            padding: 12px 16px;
            margin-bottom: 10px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 350px;
            min-width: 200px;
            transform: translateX(400px);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
            pointer-events: auto;
            border-left: 4px solid #3498db;
            font-size: 14px;
            color: #333;
            position: relative;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.info {
            border-left-color: #3498db;
        }

        .toast.success {
            border-left-color: #2ecc71;
            background: #f8fff9;
        }

        .toast.error {
            border-left-color: #e74c3c;
            background: #fff8f8;
        }

        .toast-close {
            position: absolute;
            top: 4px;
            right: 8px;
            background: none;
            border: none;
            font-size: 16px;
            color: #999;
            cursor: pointer;
            padding: 2px 4px;
            line-height: 1;
        }

        .toast-close:hover {
            color: #666;
        }

        /* Xóa các styles cũ của custom alert */
        .custom-alert-overlay,
        .custom-alert-box,
        #customAlertMessage,
        .custom-alert-close-btn {
            display: none !important;
        }

        /* Pagination styles */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
            padding: 10px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            gap: 10px;
        }

        .pagination-controls button {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .pagination-controls button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        .pagination-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 14px;
            color: #555;
            font-weight: 500;
        }

        .pagination-page-size {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .pagination-page-size label {
            font-size: 13px;
            color: #555;
        }

        .pagination-page-size select {
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 13px;
        }
    </style>
</head>

<body>
    <h2>Quản lý đơn hàng SPEEGO</h2>

    <div id="mainFilters" class="main-filters">
        <div class="filter-group">
            <label for="filterMarket">Thị trường</label>
            <select id="filterMarket">
                <option value="">Tất cả</option>
            </select>
        </div>
        <div class="filter-group">
            <label for="filterProduct">Sản phẩm</label>
            <select id="filterProduct">
                <option value="">Tất cả</option>
            </select>
        </div>
        <div class="filter-group">
            <label for="filterDateFrom">Từ ngày</label>
            <input type="date" id="filterDateFrom">
        </div>
        <div class="filter-group">
            <label for="filterDateTo">Tới ngày</label>
            <input type="date" id="filterDateTo">
        </div>
        <div class="filter-group">
            <label for="fixedColumns">Số cột cố định</label>
            <input type="number" id="fixedColumns" value="1" min="0" style="width: 60px;">
        </div>
    </div>

    <div id="tabContainer" class="tab-container"></div>

    <div class="controls">
        <div>
            <button id="refreshData" class="refresh-btn">
                <span class="refresh-icon">↻</span> Load dữ liệu
            </button>
            <button id="updateAll">Cập nhật tất cả thay đổi</button>
            <button id="downloadExcel">Tải Excel</button>
            <span id="orderCounter" class="order-counter"></span>
            <span id="selectionSummary" class="selection-summary"></span>
        </div>
        <div>
            <button id="toggleTrackingView" class="tab-btn tracking-tab">Xem đơn có mã Tracking</button>
            <!-- NÚT CHUYỂN KHO MỚI -->
            <button id="transferWarehouseBtn" class="tab-btn" disabled
                style="display: none; background-color: #f39c12; color: white;">Chuyển kho</button>
        </div>
    </div>

    <div class="table-wrapper" id="tableContainer">
        <table>
            <thead>
                <tr id="filterRow"></tr>
                <tr>
                    <th>Mã đơn hàng</th>
                    <th>Ngày lên đơn</th>
                    <th>Name*</th>
                    <th>Phone*</th>
                    <th>Add</th>
                    <th>City</th>
                    <th>State</th>
                    <th>Khu vực</th>
                    <th>Zipcode</th>
                    <th>Mặt hàng</th>
                    <th>Tên mặt hàng 1</th>
                    <th>Số lượng mặt hàng 1</th>
                    <th>Tên mặt hàng 2</th>
                    <th>Số lượng mặt hàng 2</th>
                    <th>Quà tặng</th>
                    <th>Số lượng quà kèm</th>
                    <th>Giá bán</th>
                    <th>Loại tiền thanh toán</th>
                    <th>Tổng tiền VNĐ</th>
                    <th>Hình thức thanh toán</th>
                    <th>Ghi chú</th>
                    <th>Ghi chú vận đơn</th>
                    <th>Kết quả check</th>
                    <th>Mã Tracking</th>
                    <th>Ngày đóng hàng</th>
                    <th>Trạng thái giao hàng</th>
                    <th>Thời gian giao dự kiến</th>
                    <th>Ngày Kế toán đối soát với FFM lần 2</th>
                    <th>Phí ship nội địa Mỹ (usd)</th>
                    <th>Phí xử lý đơn đóng hàng-Lưu kho(usd)</th>
                    <th>GHI CHÚ</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <!-- NEW: Pagination Controls -->
    <div id="paginationControls" class="pagination-controls">
        <button id="prevPage">Trang trước</button>
        <span id="pageInfo" class="pagination-info">Trang 1/1</span>
        <button id="nextPage">Trang sau</button>
        <div class="pagination-page-size">
            <label for="rowsPerPageSelect">Số dòng/trang:</label>
            <select id="rowsPerPageSelect">
                <option value="50">50</option>
                <option value="70" selected>70</option>
                <option value="100">100</option>
                <option value="200">200</option>
                <option value="500">500</option>
            </select>
        </div>
    </div>


    <!-- Thay thế custom alert HTML bằng toast container -->
    <div id="toastContainer" class="toast-container"></div>

    <script>
        const prod = 'https://n-api-gamma.vercel.app'
        const localhost = 'http://localhost:8081'
        const host = 'prod'
        const mainHost = host === 'prod' ? prod : localhost
        // const SCRIPT_URL = `https://script.google.com/macros/s/AKfycbx_rU4gsMXugPUK9ZoTczyWpKdsPVO3QcXzdpswFKVQmnsMU6B6J9lirCO_7NvET78/exec`;
        // const POST_URL = SCRIPT_URL; // THIS IS NOW FOR BATCH UPDATE API
        const SHEET_NAME = 'F3 test'; // Cập nhật tên sheet
        const BATCH_UPDATE_API_URL = `${mainHost}/sheet/${SHEET_NAME}/update?verbose=true`;
        const SINGLE_UPDATE_API_URL = `${mainHost}/sheet/${SHEET_NAME}/update-single`;
        // URL API mới để chuyển kho
        const TRANSFER_API_URL = `${mainHost}/sheet/MGT nội bộ test/rows/batch`; // API của bạn
        // NEW API for MGT Nội Bộ tab ORDERING
        const MGT_NOI_BO_ORDER_API_URL = `${mainHost}/sheet/MGT nội bộ test/data`;

        // *** THAY ĐỔI 1: Định nghĩa tên cột để tạo Tab. Bạn có thể thay đổi "Team" thành tên cột khác nếu cần. ***
        const TEAM_COLUMN_NAME = "Team";
        const PRIMARY_KEY_COLUMN = "Mã đơn hàng"; // Định nghĩa cột Primary Key

        const displayColumns = ["Mã đơn hàng", "Ngày lên đơn", "Name*", "Phone*", "Add", "City", "State", "Khu vực", "Zipcode", "Mặt hàng", "Tên mặt hàng 1", "Số lượng mặt hàng 1", "Tên mặt hàng 2", "Số lượng mặt hàng 2", "Quà tặng", "Số lượng quà kèm", "Giá bán", "Loại tiền thanh toán", "Tổng tiền VNĐ", "Hình thức thanh toán", "Ghi chú", "Ghi chú vận đơn", "Kết quả check", "Mã Tracking", "Ngày đóng hàng", "Trạng thái giao hàng", "Thời gian giao dự kiến", "Ngày Kế toán đối soát với FFM lần 2", "Phí ship nội địa Mỹ (usd)", "Phí xử lý đơn đóng hàng-Lưu kho(usd)", "GHI CHÚ"];
        const columnMapping = { "Ghi chú vận đơn": "ngày hẹn đẩy đơn", "Kết quả check": "Kết quả Check" }; // Maps display name to actual data key if different

        const editableCols = ["Kết quả check", "Mã Tracking", "Ngày đóng hàng", "Trạng thái giao hàng", "Thời gian giao dự kiến", "Phí ship nội địa Mỹ (usd)", "Phí xử lý đơn đóng hàng-Lưu kho(usd)", "GHI CHÚ"];
        const checkStatusOptions = ["", "OK", "Huỷ", "Chờ check lại", "Sai SĐT", "Sai địa chỉ", "Khác"];


        // ===== STATE MANAGEMENT REFACTORED =====
        let state = {
            allData: [], // Stores original data from server
            pendingChanges: new Map(), // Map<orderId, Map<columnName, {newValue, originalValue, cellElement}>>
            activeTeam: 'all',
            showTrackingOrders: false,
            filterValues: {},
            mgtNoiBoOrder: [], // NEW: To store the ordered list from MGT Nội Bộ API
            isMgtNoiBoOrderLoading: false, // NEW: To track loading state for MGT Nội Bộ
            // NEW: Pagination state
            currentPage: 1,
            rowsPerPage: 70, // Default rows per page
            totalFilteredOrders: 0 // Total orders after all filters, before pagination
        };
        let pasteAnchorCell = null;
        let isUpdatingSingleCell = false; // Flag to prevent multiple single updates or batch update during single update
        let isPasting = false; // Flag to indicate a paste operation is in progress


        // --- HÀM THÔNG BÁO TOAST MỚI ---
        function showCustomAlert(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');

            // Tạo toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            // Tạo nội dung toast
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;

            // Tạo nút đóng
            const closeBtn = document.createElement('button');
            closeBtn.className = 'toast-close';
            closeBtn.innerHTML = '×';
            closeBtn.onclick = () => removeToast(toast);

            // Thêm vào toast
            toast.appendChild(messageSpan);
            toast.appendChild(closeBtn);

            // Thêm vào container
            container.appendChild(toast);

            // Hiển thị toast
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Tự động ẩn toast sau duration (trừ khi duration = 0)
            if (duration > 0) {
                setTimeout(() => {
                    removeToast(toast);
                }, duration);
            }

            // Trả về toast element để có thể xử lý manually nếu cần
            return toast;
        }

        function removeToast(toast) {
            if (!toast || !toast.parentNode) return;

            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }

        // Hàm utility để xóa tất cả toast (dùng khi cần clear notifications)
        function clearAllToasts() {
            const container = document.getElementById('toastContainer');
            const toasts = container.querySelectorAll('.toast');
            toasts.forEach(toast => removeToast(toast));
        }

        // --- CÁC HÀM UTILITY ---
        function formatDate(dateString) { if (!dateString) return ''; try { const date = new Date(dateString.includes('Z') ? dateString : dateString + 'Z'); if (isNaN(date.getTime())) return dateString; const day = String(date.getDate()).padStart(2, '0'); const month = String(date.getMonth() + 1).padStart(2, '0'); const year = date.getFullYear(); return `${day}/${month}/${year}`; } catch (e) { return dateString; } }
        function parseDateToISO(dateString) { // Chuyển dd/mm/yyyy thành ISO string
            if (!dateString || dateString.length === 0) return '';
            const parts = dateString.split('/');
            if (parts.length === 3) {
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10) - 1; // Months are 0-indexed
                const year = parseInt(parts[2], 10);
                const date = new Date(year, month, day);
                if (!isNaN(date.getTime())) {
                    // Return ISO string without time, usually YYYY-MM-DD
                    return date.toISOString().split('T')[0];
                }
            }
            return dateString; // Fallback to original if invalid format
        }
        function updateOrderCounter(count) { const counterElement = document.getElementById('orderCounter'); if (counterElement) { counterElement.innerHTML = `Tổng số đơn: <b>${count}</b>`; } }


        // --- LOCAL STORAGE HANDLING ---
        function savePendingChangesToLocalStorage() {
            const serializableChanges = {};
            state.pendingChanges.forEach((colChanges, orderId) => {
                serializableChanges[orderId] = {};
                colChanges.forEach((changeInfo, colName) => {
                    serializableChanges[orderId][colName] = {
                        newValue: changeInfo.newValue,
                        originalValue: changeInfo.originalValue,
                        // Do not save cellElement to localStorage
                    };
                });
            });
            localStorage.setItem('speegoPendingChanges', JSON.stringify(serializableChanges));
        }

        function loadPendingChangesFromLocalStorage() {
            const storedChanges = localStorage.getItem('speegoPendingChanges');
            if (storedChanges) {
                try {
                    const parsedChanges = JSON.parse(storedChanges);
                    state.pendingChanges.clear();
                    for (const orderId in parsedChanges) {
                        const colChangesMap = new Map();
                        for (const colName in parsedChanges[orderId]) {
                            colChangesMap.set(colName, {
                                newValue: parsedChanges[orderId][colName].newValue,
                                originalValue: parsedChanges[orderId][colName].originalValue,
                                cellElement: null // Will be re-attached during rendering
                            });
                        }
                        state.pendingChanges.set(orderId, colChangesMap);
                    }
                } catch (e) {
                    console.error("Lỗi khi đọc lịch sử thay đổi từ localStorage:", e);
                    localStorage.removeItem('speegoPendingChanges');
                }
            }
        }

        // --- XỬ LÝ DỮ LIỆU VÀ LỌC ---
        function handleData(response) {
            document.getElementById('refreshData').disabled = false;
            document.getElementById('refreshData').innerHTML = '<span class="refresh-icon">↻</span> Load dữ liệu';
            state.allData = [];
            if (response.error) { showCustomAlert(`Lỗi tải dữ liệu: ${response.error}`, 'error'); return; }
            const data = response.rows || response.data || response;
            if (!Array.isArray(data)) { showCustomAlert('Dữ liệu trả về không hợp lệ.', 'error'); return; }
            state.allData = data;

            // After loading new data, re-evaluate pending changes to remove any that are now consistent
            // with the server, or re-highlight if server data is still different
            // For simplicity, we just keep the pendingChanges as they are from localStorage initially
            // and let render() decide highlighting.

            const initialDataForFilters = filterByCarrier(state.allData);
            populateMainFilters(initialDataForFilters);
            createTabs(initialDataForFilters); // *** THAY ĐỔI 3: Gọi lại hàm createTabs với dữ liệu để nó tự tạo tab ***
            setupColumnFilters();
            // If the "MGT nội bộ" tab is currently active, we need to load its specific order.
            if (state.activeTeam === 'mgt_noi_bo' && state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) {
                fetchMGTNoiBoOrder().then(render); // Fetch order then render
            } else {
                render();
            }
        }

        function filterByCarrier(data) {
            return data.filter(row => {
                const carrier = row["Đơn vị vận chuyển"] || row["Đơn_vị_vận_chuyển"];
                return carrier?.toString().toUpperCase() === "MGT";
            });
        }

        // NEW: Function to fetch the MGT Nội Bộ ordering data
        async function fetchMGTNoiBoOrder() {
            if (state.isMgtNoiBoOrderLoading) return;
            state.isMgtNoiBoOrderLoading = true;
            // Store the returned toast element for later dismissal
            const loadingToast = showCustomAlert('Đang tải danh sách đơn hàng nội bộ...', 'info', 0); // Show persistent loading alert
            try {
                const response = await fetch(MGT_NOI_BO_ORDER_API_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const json = await response.json();
                if (json.data && Array.isArray(json.data)) {
                    state.mgtNoiBoOrder = json.data.map(row => row[PRIMARY_KEY_COLUMN]).filter(Boolean);
                    removeToast(loadingToast); // Dismiss loading toast
                    showCustomAlert('Đã tải danh sách đơn hàng nội bộ.', 'success', 2000);
                } else {
                    state.mgtNoiBoOrder = [];
                    removeToast(loadingToast); // Dismiss loading toast
                    showCustomAlert('Không thể tải danh sách đơn hàng nội bộ hoặc dữ liệu không hợp lệ.', 'error');
                }
            } catch (e) {
                console.error('Lỗi khi tải dữ liệu MGT Nội Bộ:', e);
                removeToast(loadingToast); // Dismiss loading toast
                showCustomAlert(`Lỗi kết nối khi tải danh sách đơn hàng nội bộ: ${e.message}`, 'error');
                state.mgtNoiBoOrder = [];
            } finally {
                state.isMgtNoiBoOrderLoading = false;
                // Ensure the persistent loading alert is hidden if it was specifically for this fetch
                // This line is now redundant because `removeToast(loadingToast)` handles it.
                // const currentAlertMessage = document.getElementById('customAlertMessage').textContent;
                // if (document.getElementById('customAlert').classList.contains('show') &&
                //     currentAlertMessage === 'Đang tải danh sách đơn hàng nội bộ...') {
                //     document.getElementById('customAlert').classList.remove('show');
                // }
            }
        }

        function populateMainFilters(data) {
            const marketFilter = document.getElementById('filterMarket');
            const productFilter = document.getElementById('filterProduct');
            const markets = [...new Set(data.map(row => row["Khu vực"]).filter(Boolean))].sort();
            const products = [...new Set(data.map(row => row["Mặt hàng"]).filter(Boolean))].sort();
            marketFilter.innerHTML = '<option value="">Tất cả Thị trường</option>';
            productFilter.innerHTML = '<option value="">Tất cả Sản phẩm</option>';
            markets.forEach(market => marketFilter.innerHTML += `<option value="${market}">${market}</option>`);
            products.forEach(product => productFilter.innerHTML += `<option value="${product}">${product}</option>`);
        }

        // Modified getFilteredData to handle pagination
        function getFilteredData() {
            const mergedData = state.allData.map(originalRow => {
                const orderId = originalRow[PRIMARY_KEY_COLUMN];
                const changes = state.pendingChanges.get(orderId);
                if (changes) {
                    const changeObject = {};
                    changes.forEach((changeInfo, key) => { changeObject[key] = changeInfo.newValue; });
                    return { ...originalRow, ...changeObject };
                }
                return originalRow;
            });

            const mgtData = filterByCarrier(mergedData);

            let dataToRender = mgtData.filter(row => {
                const trackingCode = String(row["Mã Tracking"] || row["Mã_Tracking"] || '');
                return state.showTrackingOrders ? trackingCode.trim() !== '' : !trackingCode.trim();
            });

            const market = document.getElementById('filterMarket').value;
            const product = document.getElementById('filterProduct').value;
            const dateFrom = document.getElementById('filterDateFrom').value;
            const dateTo = document.getElementById('filterDateTo').value;

            if (market) { dataToRender = dataToRender.filter(row => row["Khu vực"] === market); }
            if (product) { dataToRender = dataToRender.filter(row => row["Mặt hàng"] === product); }
            if (dateFrom) { const from = new Date(dateFrom); from.setHours(0, 0, 0, 0); dataToRender = dataToRender.filter(row => row["Ngày lên đơn"] && new Date(row["Ngày lên đơn"]) >= from); }
            if (dateTo) { const to = new Date(dateTo); to.setHours(23, 59, 59, 999); dataToRender = dataToRender.filter(row => row["Ngày lên đơn"] && new Date(row["Ngày lên đơn"]) <= to); }

            // *** THAY ĐỔI 4: Logic lọc theo tab dựa trên cột "Team" (hoặc tên cột bạn định nghĩa ở TEAM_COLUMN_NAME) ***
            // Handle "MGT nội bộ" tab for specific ordering
            if (state.activeTeam === 'mgt_noi_bo') {
                if (state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) {
                    // If the order list is empty and not currently loading, display no data.
                    // A loading message should already be shown by fetchMGTNoiBoOrder().
                    state.totalFilteredOrders = 0; // NEW: update total filtered count
                    return [];
                }

                const orderedIds = new Set(state.mgtNoiBoOrder);
                // Filter dataToRender to only include orders present in mgtNoiBoOrder
                dataToRender = dataToRender.filter(row => orderedIds.has(row["Mã đơn hàng"]));
                // Create a map for quick lookup of order IDs to their index in the ordered list
                const orderIndexMap = new Map(state.mgtNoiBoOrder.map((id, index) => [id, index]));
                // Sort dataToRender based on the mgtNoiBoOrder
                dataToRender.sort((a, b) => {
                    const indexA = orderIndexMap.get(a[PRIMARY_KEY_COLUMN]);
                    const indexB = orderIndexMap.get(b[PRIMARY_KEY_COLUMN]);
                    return indexA - indexB;
                });
            } else if (state.activeTeam !== 'all') {
                dataToRender = dataToRender.filter(row => row[TEAM_COLUMN_NAME] === state.activeTeam);
            }

            const trackingIncludeRaw = state.filterValues['tracking_include'] || '';
            const trackingExcludeRaw = state.filterValues['tracking_exclude'] || '';
            const otherColumnFilters = Object.entries(state.filterValues).filter(([key, val]) => val.trim() !== '' && !key.startsWith('tracking_'));

            if (otherColumnFilters.length > 0) {
                dataToRender = dataToRender.filter(row => {
                    return otherColumnFilters.every(([col, filterValue]) => {
                        const dataKey = columnMapping[col] || col;
                        const cellValue = row[dataKey] ?? row[col] ?? row[dataKey.replace(/ /g, '_')] ?? '';
                        return String(cellValue).toLowerCase().includes(filterValue.toLowerCase());
                    });
                });
            }

            if (trackingIncludeRaw || trackingExcludeRaw) {
                const lowerInclude = trackingIncludeRaw.toLowerCase();
                const lowerExclude = trackingExcludeRaw.toLowerCase();
                dataToRender = dataToRender.filter(row => {
                    const cellValue = String(row['Mã Tracking'] || '');
                    const lowerCellValue = cellValue.toLowerCase();
                    if (lowerExclude && lowerCellValue.includes(lowerExclude)) { return false; }
                    if (lowerInclude) {
                        if (lowerInclude.includes('\n')) {
                            const codes = new Set(trackingIncludeRaw.split('\n').map(t => t.trim()).filter(Boolean));
                            if (!codes.has(cellValue.trim())) return false;
                        } else {
                            if (!lowerCellValue.includes(lowerInclude)) return false;
                        }
                    }
                    return true;
                });
            }

            // ===== START: MODIFIED SORTING LOGIC (Đã kiểm tra và thấy logic này hoạt động đúng) =====
            // ONLY apply this sorting if NOT on the MGT Nội Bộ tab
            if (state.activeTeam !== 'mgt_noi_bo') {
                const primarySortKey = 'Ngày Kế toán đối soát với FFM lần 2';
                const secondarySortKey = PRIMARY_KEY_COLUMN;

                dataToRender.sort((a, b) => {
                    const parseDate = (val) => { if (!val) return null; const date = new Date(val); return isNaN(date.getTime()) ? null : date; };
                    const dateA = parseDate(a[primarySortKey]);
                    const dateB = parseDate(b[primarySortKey]);

                    // So sánh theo khóa chính (ngày đối soát)
                    if (dateA === null && dateB === null) {
                        // Cả hai đều null, chuyển sang sắp xếp theo khóa phụ
                    } else if (dateA === null) {
                        return 1; // Đẩy giá trị null của A xuống cuối
                    } else if (dateB === null) {
                        return -1; // Đẩy giá trị null của B xuống cuối
                    } else {
                        const dateComparison = dateA.getTime() - dateB.getTime();
                        if (dateComparison !== 0) {
                            return dateComparison; // Trả về kết quả nếu ngày khác nhau (bao gồm giờ, phút, giây)
                        }
                        // Nếu ngày giờ giống hệt nhau, sẽ chuyển sang sắp xếp theo khóa phụ
                    }

                    // So sánh theo khóa phụ (Mã đơn hàng) khi khóa chính bằng nhau
                    const orderIdA = a[secondarySortKey] || '';
                    const orderIdB = b[secondarySortKey] || '';
                    // Sử dụng localeCompare để sắp xếp chuỗi một cách chính xác
                    return orderIdA.localeCompare(orderIdB);
                });
            }
            // ===== END: MODIFIED SORTING LOGIC =====

            // NEW: Apply pagination
            state.totalFilteredOrders = dataToRender.length; // Store total filtered count before pagination
            const startIndex = (state.currentPage - 1) * state.rowsPerPage;
            const endIndex = startIndex + state.rowsPerPage;
            return dataToRender.slice(startIndex, endIndex);
        }

        // --- HÀM CỐ ĐỊNH CỘT ĐỘNG ---
        function updateFixedColumns() {
            const numFixed = parseInt(document.getElementById('fixedColumns').value, 10);
            const table = document.querySelector('.table-wrapper table');
            if (!table) return;
            const rows = Array.from(table.rows);
            rows.forEach(row => {
                Array.from(row.cells).forEach(cell => {
                    cell.classList.remove('fixed-column');
                    cell.style.left = '';
                });
            });
            if (numFixed <= 0 || rows.length < 2) return;
            const headerCells = rows[1].cells;
            const offsets = [0];
            for (let i = 1; i < numFixed; i++) {
                if (headerCells[i - 1]) {
                    offsets[i] = offsets[i - 1] + headerCells[i - 1].offsetWidth;
                }
            }
            rows.forEach(row => {
                for (let i = 0; i < numFixed; i++) {
                    const cell = row.cells[i];
                    if (cell) {
                        cell.classList.add('fixed-column');
                        cell.style.left = `${offsets[i] || 0}px`;
                    }
                }
            });
        }

        // --- RENDER GIAO DIỆN ---
        function render() {
            const paginatedData = getFilteredData(); // This now returns only the data for the current page
            const container = document.getElementById('tableBody');
            container.innerHTML = '';
            if (paginatedData.length === 0) {
                let message = 'Không có dữ liệu phù hợp';
                if (state.activeTeam === 'mgt_noi_bo' && state.isMgtNoiBoOrderLoading) {
                    message = 'Đang tải danh sách đơn hàng nội bộ...'; // Show specific message if loading order
                }
                container.innerHTML = `<tr><td colspan="${displayColumns.length}" class="no-data">${message}</td></tr>`;
                updateOrderCounter(state.totalFilteredOrders); // NEW: Display total filtered count
                updatePaginationControls(); // NEW: Update pagination controls even if no data
                return;
            }
            updateOrderCounter(state.totalFilteredOrders); // NEW: Display total filtered count
            paginatedData.forEach((row) => { // Render only paginated data
                const tr = document.createElement('tr');
                const orderId = row[PRIMARY_KEY_COLUMN];
                tr.dataset.orderId = orderId;

                displayColumns.forEach(col => {
                    const td = document.createElement('td');
                    const dataKey = columnMapping[col] || col;
                    let originalValue = String(row[dataKey] ?? row[col] ?? row[col.replace(/ /g, '_')] ?? ''); // Value from the current 'merged' data

                    let displayValue = originalValue;
                    if (["Ngày lên đơn", "Ngày đóng hàng"].includes(col)) {
                        displayValue = formatDate(originalValue);
                    }

                    if (col === "Ghi chú vận đơn" && displayValue) { td.classList.add('note-highlight'); }
                    const checkValue = String(displayValue).trim().toLowerCase();
                    td.classList.remove('status-ok', 'status-cancel');
                    if (col === "Kết quả check") {
                        if (checkValue === 'ok') td.classList.add('status-ok');
                        else if (checkValue.includes('huỷ')) td.classList.add('status-cancel');
                    }
                    if (editableCols.includes(col)) {
                        td.classList.add('editable');
                        // Check if this specific cell has a pending change
                        const pendingChange = state.pendingChanges.get(orderId)?.get(dataKey);
                        if (pendingChange) {
                            td.classList.add('highlight');
                            displayValue = (col === "Ngày đóng hàng") ? formatDate(pendingChange.newValue) : String(pendingChange.newValue); // Display pending value
                            pendingChange.cellElement = td; // Re-attach cell element
                        } else {
                            td.classList.remove('highlight');
                        }

                        // --- Event handling for single cell update ---
                        const handleCellChange = (newValue, element) => {
                            if (isUpdatingSingleCell) return; // Prevent new update if one is in progress

                            // Get the current value for comparison
                            let currentDisplayValue = getCellValue(element.closest('td') || element);
                            let finalValueForState = newValue;

                            // Handle specific column formatting for actual storage value
                            if (col === "Ngày đóng hàng") {
                                // For date input, the `newValue` is already in dd/mm/yyyy from element.value
                                finalValueForState = new Date(newValue).toLocaleDateString('en-US')
                            } else {
                                finalValueForState = String(newValue);
                            }

                            // Find the original data row (the one *without* pending changes merged)
                            const initialRowData = state.allData.find(r => r[PRIMARY_KEY_COLUMN] === orderId);
                            const initialDataKeyValue = initialRowData ? String(initialRowData[dataKey] ?? '') : '';

                            // Determine the effective original value (the value that the server currently has or had before a *successful* update)
                            // This is important because `originalValue` stored in pendingChanges might be an intermediate value
                            // if an update failed. We need to compare against what the server *should* have.
                            const originalValueFromServer = String(row[dataKey] ?? ''); // Use the 'row' parameter which might contain values from `allData` or previous successful single updates

                            // Compare the new value with the value from the current row (which includes successfully applied changes)
                            const isChanged = finalValueForState !== originalValueFromServer;

                            if (isChanged) {
                                if (!state.pendingChanges.has(orderId)) {
                                    state.pendingChanges.set(orderId, new Map());
                                }
                                const changeInfo = {
                                    newValue: finalValueForState,
                                    originalValue: originalValueFromServer, // Store original value from the server as reference
                                    cellElement: td // Store reference to the actual cell
                                };
                                state.pendingChanges.get(orderId).set(dataKey, changeInfo);
                                td.classList.add('highlight');
                                savePendingChangesToLocalStorage();
                                
                                // === MODIFIED LOGIC: Only call single update when NOT pasting ===
                                if (!isPasting) {
                                    handleSingleCellUpdate(orderId, dataKey, finalValueForState, td);
                                }

                            } else {
                                // If value is back to original, remove from pending changes
                                const orderChanges = state.pendingChanges.get(orderId);
                                if (orderChanges) {
                                    orderChanges.delete(dataKey);
                                    if (orderChanges.size === 0) {
                                        state.pendingChanges.delete(orderId);
                                    }
                                    td.classList.remove('highlight');
                                    savePendingChangesToLocalStorage();
                                }
                            }
                            updateSelectionSummary(); // Re-evaluate selection summary as change count might affect it
                        };


                        if (col === "Kết quả check") {
                            td.classList.add('editable-dropdown-cell');
                            const select = document.createElement('select');
                            select.className = 'editable-select';
                            const currentVal = String(displayValue); // Use displayValue for setting selected option
                            const optionsToAdd = new Set(checkStatusOptions);
                            if (currentVal && !optionsToAdd.has(currentVal)) {
                                optionsToAdd.add(currentVal);
                            }
                            Array.from(optionsToAdd).sort().forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt; option.textContent = opt;
                                if (opt.toLowerCase() === currentVal.toLowerCase()) { option.selected = true; }
                                select.appendChild(option);
                            });
                            select.addEventListener('change', () => {
                                handleCellChange(select.value, select);
                                const selectedVal = select.value.toLowerCase();
                                td.classList.remove('status-ok', 'status-cancel');
                                if (selectedVal === 'ok') td.classList.add('status-ok');
                                else if (selectedVal.includes('huỷ')) td.classList.add('status-cancel');
                            });
                            td.innerHTML = '';
                            td.appendChild(select);
                        } else if (col === "Ngày đóng hàng") {
                            const input = document.createElement('input');
                            input.type = 'date'; 
                            input.className = 'date-input'; 
                            input.value = displayValue;
                            td.style.padding = '0'; 
                            input.style.padding = '8px 12px';
                            
                            input.addEventListener('change', () => {
                                handleCellChange(input.value, input);
                            });
                            input.addEventListener('blur', () => {
                                handleCellChange(input.value, input);
                            });
                            
                            td.innerHTML = ''; 
                            td.appendChild(input);
                        } else {
                            td.contentEditable = 'true';
                            td.textContent = displayValue;
                            td.addEventListener('blur', () => handleCellChange(td.textContent, td));
                        }
                    } else {
                        td.textContent = displayValue;
                    }
                    tr.appendChild(td);
                });
                container.appendChild(tr);
            });
            updateFixedColumns();
            updatePaginationControls(); // NEW: Update pagination controls after rendering
        }

        // NEW: Function to update pagination controls
        function updatePaginationControls() {
            const prevBtn = document.getElementById('prevPage');
            const nextPage = document.getElementById('nextPage');
            const pageInfo = document.getElementById('pageInfo');
            const rowsPerPageSelect = document.getElementById('rowsPerPageSelect');

            const totalPages = Math.ceil(state.totalFilteredOrders / state.rowsPerPage);
            pageInfo.textContent = `Trang ${state.currentPage}/${totalPages || 1}`;

            prevBtn.disabled = state.currentPage <= 1;
            nextPage.disabled = state.currentPage >= totalPages;

            // Set the selected value for rowsPerPageSelect
            rowsPerPageSelect.value = state.rowsPerPage;
        }


        // --- HÀM MỚI: CẬP NHẬT MỘT Ô DUY NHẤT ---
        async function handleSingleCellUpdate(orderId, columnKey, newValue, cellElement) {
            if (isUpdatingSingleCell) return;
            isUpdatingSingleCell = true;
            document.getElementById('updateAll').disabled = true;

            // Hiển thị loading toast (persistent)
            const loadingToast = showCustomAlert('Đang cập nhật...', 'info', 0);

            try {
                const payload = {
                    [PRIMARY_KEY_COLUMN]: orderId,
                    [columnKey]: newValue
                };

                const response = await fetch(SINGLE_UPDATE_API_URL, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(errorResponse.message || `Lỗi HTTP! status: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    // Update state.allData with the successful change
                    const originalRowIndex = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === orderId);
                    if (originalRowIndex !== -1) {
                        state.allData[originalRowIndex] = {
                            ...state.allData[originalRowIndex],
                            [columnKey]: newValue
                        };
                    }

                    // Remove change from pendingChanges and localStorage
                    const orderChanges = state.pendingChanges.get(orderId);
                    if (orderChanges) {
                        orderChanges.delete(columnKey);
                        if (orderChanges.size === 0) {
                            state.pendingChanges.delete(orderId);
                        }
                    }
                    cellElement.classList.remove('highlight');
                    savePendingChangesToLocalStorage();

                    // Xóa loading toast và hiển thị success
                    removeToast(loadingToast);
                    showCustomAlert('Cập nhật thành công!', 'success', 2000);
                } else {
                    removeToast(loadingToast);
                    showCustomAlert(`Lỗi cập nhật: ${result.message || 'Lỗi không xác định.'}`, 'error');
                }

            } catch (error) {
                console.error('Lỗi khi cập nhật đơn lẻ:', error);
                removeToast(loadingToast);
                showCustomAlert(`Lỗi kết nối: ${error.message}`, 'error');
            } finally {
                isUpdatingSingleCell = false;
                document.getElementById('updateAll').disabled = false;
            }
        }

        // *** THAY ĐỔI 5: Viết lại hàm createTabs để tự động tạo tab từ cột "Team" VÀ thêm tab "MGT nội bộ" ***
        function createTabs(data) {
            const tabContainer = document.getElementById('tabContainer');
            tabContainer.innerHTML = '';
            const teams = [...new Set(data.map(row => row[TEAM_COLUMN_NAME]).filter(Boolean))].sort();

            const createTab = (name, value) => {
                const button = document.createElement('button');
                button.className = 'tab-btn';
                button.textContent = name;
                button.dataset.team = value;
                if (value === state.activeTeam) {
                    button.classList.add('active');
                }
                button.addEventListener('click', async () => {
                    state.activeTeam = value;
                    state.currentPage = 1; // NEW: Reset page on tab change
                    document.querySelectorAll('#tabContainer .tab-btn').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    if (value === 'mgt_noi_bo' && state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) {
                        await fetchMGTNoiBoOrder();
                    }
                    render();
                });
                return button;
            };

            tabContainer.appendChild(createTab('Tất cả', 'all'));
            // Add the "MGT nội bộ" tab explicitly
            tabContainer.appendChild(createTab('MGT nội bộ', 'mgt_noi_bo'));
            teams.forEach(team => tabContainer.appendChild(createTab(team, team)));
        }

        function setupColumnFilters() {
            const filterRow = document.getElementById('filterRow');
            filterRow.innerHTML = '';
            // Restore filter values after refresh/load
            const storedFilterValues = localStorage.getItem('speegoColumnFilters');
            if (storedFilterValues) {
                try {
                    state.filterValues = JSON.parse(storedFilterValues);
                } catch (e) {
                    console.error("Lỗi khi đọc filterValues từ localStorage:", e);
                    state.filterValues = {};
                }
            } else {
                state.filterValues = {};
            }

            displayColumns.forEach((col, index) => {
                const th = document.createElement('th');
                if (col === "Mã Tracking") {
                    const container = document.createElement('div'); container.className = 'dual-filter-container';
                    const includeInput = document.createElement('input'); includeInput.type = 'text'; includeInput.className = 'filter-input'; includeInput.placeholder = 'Bao gồm...';
                    includeInput.value = state.filterValues['tracking_include'] || '';
                    includeInput.addEventListener('input', () => {
                        state.filterValues['tracking_include'] = includeInput.value;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        state.currentPage = 1; // NEW: Reset page on filter change
                        render();
                    });
                    const excludeInput = document.createElement('input'); excludeInput.type = 'text'; excludeInput.className = 'filter-input'; excludeInput.placeholder = 'Loại trừ...';
                    excludeInput.value = state.filterValues['tracking_exclude'] || '';
                    excludeInput.addEventListener('input', () => {
                        state.filterValues['tracking_exclude'] = excludeInput.value;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        state.currentPage = 1; // NEW: Reset page on filter change
                        render();
                    });
                    container.appendChild(includeInput); container.appendChild(excludeInput); th.appendChild(container);
                } else {
                    const input = document.createElement('input'); input.type = 'text'; input.className = 'filter-input'; input.placeholder = `Lọc ${col}`; input.dataset.column = col;
                    input.value = state.filterValues[col] || '';
                    input.addEventListener('input', () => {
                        state.filterValues[col] = input.value;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        state.currentPage = 1; // NEW: Reset page on filter change
                        render();
                    });
                    th.appendChild(input);
                }
                filterRow.appendChild(th);
            });
        }

        // --- CÁC HÀM ĐIỀU KHIỂN ---
        function setupControls() {
            document.getElementById('refreshData').addEventListener('click', () => {
                refreshData();
            });

            document.getElementById('updateAll').addEventListener('click', () => {
                updateAllChangedRows();
            });

            document.getElementById('toggleTrackingView').addEventListener('click', () => {
                toggleTrackingView();
                state.currentPage = 1; // NEW: Reset page on toggle tracking view
            });
            document.getElementById('filterMarket').addEventListener('change', () => {
                state.currentPage = 1; // NEW: Reset page on filter change
                render();
            });
            document.getElementById('filterProduct').addEventListener('change', () => {
                state.currentPage = 1; // NEW: Reset page on filter change
                render();
            });
            document.getElementById('filterDateFrom').addEventListener('change', () => {
                state.currentPage = 1; // NEW: Reset page on filter change
                render();
            });
            document.getElementById('filterDateTo').addEventListener('change', () => {
                state.currentPage = 1; // NEW: Reset page on filter change
                render();
            });
            document.getElementById('downloadExcel').addEventListener('click', downloadAsExcel);
            document.getElementById('fixedColumns').addEventListener('change', updateFixedColumns);
            document.getElementById('transferWarehouseBtn').addEventListener('click', transferSelectedOrders);

            // NEW: Pagination event listeners
            document.getElementById('prevPage').addEventListener('click', () => {
                if (state.currentPage > 1) {
                    state.currentPage--;
                    render();
                }
            });
            document.getElementById('nextPage').addEventListener('click', () => {
                const totalPages = Math.ceil(state.totalFilteredOrders / state.rowsPerPage);
                if (state.currentPage < totalPages) {
                    state.currentPage++;
                    render();
                }
            });
            document.getElementById('rowsPerPageSelect').addEventListener('change', (e) => {
                state.rowsPerPage = parseInt(e.target.value, 10);
                state.currentPage = 1; // Reset to first page when changing rows per page
                render();
            });
        }

        async function loadData() {
            document.getElementById('tableBody').innerHTML = `<tr><td colspan="${displayColumns.length}" style="text-align: center;">Đang tải...</td></tr>`;

            try {
                const response = await fetch(`${mainHost}/sheet/${SHEET_NAME}/data`, { // Sử dụng SHEET_NAME ở đây
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                handleData(data);

            } catch (error) {
                console.error('Lỗi khi tải dữ liệu:', error);
                showCustomAlert(`Lỗi kết nối: ${error.message}`, 'error');
                document.getElementById('refreshData').disabled = false;
                document.getElementById('refreshData').innerHTML = '<span class="refresh-icon">↻</span> Load dữ liệu';
            }
        }

        async function refreshData() {
            if (isUpdatingSingleCell) {
                showCustomAlert('Đang có thao tác cập nhật đơn lẻ, vui lòng đợi.', 'info');
                return;
            }

            const btn = document.getElementById('refreshData');
            btn.disabled = true;
            btn.innerHTML = '<span class="refresh-icon">↻</span> Đang tải...';

            state.activeTeam = 'all';
            state.filterValues = {}; // Clear filters on refresh
            localStorage.removeItem('speegoColumnFilters'); // Clear saved filters
            state.mgtNoiBoOrder = [];
            state.currentPage = 1; // NEW: Reset page on refresh

            document.getElementById('tabContainer').innerHTML = '';
            document.getElementById('filterRow').innerHTML = '';
            document.getElementById('mainFilters').querySelectorAll('input, select').forEach(el => {
                if (el.id !== 'fixedColumns') el.value = '';
            });
            updateOrderCounter(0);

            // Re-load pending changes from local storage after data is refreshed.
            // This ensures changes are maintained even if data is re-fetched.
            loadPendingChangesFromLocalStorage();

            await loadData();
        }

        async function updateAllChangedRows() {
            if (isUpdatingSingleCell) {
                showCustomAlert('Đang có thao tác cập nhật đơn lẻ, vui lòng đợi.', 'info');
                return;
            }
            if (state.pendingChanges.size === 0) {
                showCustomAlert('Không có thay đổi cần cập nhật.', 'info');
                return;
            }

            const updateBtn = document.getElementById('updateAll');
            updateBtn.disabled = true;
            updateBtn.textContent = 'Đang gửi...';

            // Hiển thị loading toast (persistent)
            const loadingToast = showCustomAlert('Đang cập nhật tất cả thay đổi...', 'info', 0);

            const rowsToSend = [];
            state.pendingChanges.forEach((changes, orderId) => {
                const changeObject = { [PRIMARY_KEY_COLUMN]: orderId };
                changes.forEach((changeInfo, colName) => {
                    changeObject[colName] = changeInfo.newValue;
                });
                rowsToSend.push(changeObject);
            });

            if (rowsToSend.length === 0) {
                updateBtn.disabled = false;
                updateBtn.textContent = 'Cập nhật tất cả thay đổi';
                showCustomAlert('Không có thay đổi cần cập nhật.', 'info');
                return;
            }

            try {
                const response = await fetch(BATCH_UPDATE_API_URL, {
                    method: 'PATCH', // Changed to PATCH
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(rowsToSend)
                });

                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(errorResponse.message || `Lỗi HTTP! status: ${response.status}`);
                }

                const json = await response.json();

                if (json.success) {
                    removeToast(loadingToast);
                    showCustomAlert(`Cập nhật thành công ${json.summary.updated} đơn hàng!`, 'success');

                    // Update local state.allData for all successfully updated rows
                    json.details.forEach(detail => {
                        if (detail.status === 'updated') {
                            const updatedRowData = rowsToSend.find(r => r[PRIMARY_KEY_COLUMN] === detail.primaryKey);
                            if (updatedRowData) {
                                const index = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === updatedRowData[PRIMARY_KEY_COLUMN]);
                                if (index !== -1) {
                                    state.allData[index] = { ...state.allData[index], ...updatedRowData };
                                }
                            }
                        }
                    });

                    state.pendingChanges.clear(); // Clear all pending changes
                    savePendingChangesToLocalStorage(); // Update localStorage
                    render(); // Re-render to remove all highlights
                } else {
                    removeToast(loadingToast);
                    showCustomAlert(`Lỗi: ${json.message || 'Lỗi không xác định.'}`, 'error');
                }

            } catch (error) {
                console.error('Lỗi khi cập nhật hàng loạt:', error);
                removeToast(loadingToast);
                showCustomAlert(`Lỗi kết nối: ${error.message}`, 'error');
            } finally {
                updateBtn.disabled = false;
                updateBtn.textContent = 'Cập nhật tất cả thay đổi';
            }
        }

        // === NEW FUNCTION: Batch update for pasted data ===
        async function batchUpdatePastedData(rowsToSend) {
            if (rowsToSend.length === 0) {
                return;
            }

            const updateBtn = document.getElementById('updateAll');
            updateBtn.disabled = true; // Vô hiệu hóa nút cập nhật chung trong quá trình này
            const loadingToast = showCustomAlert(`Đang cập nhật ${rowsToSend.length} thay đổi đã dán...`, 'info', 0);

            try {
                const response = await fetch(BATCH_UPDATE_API_URL, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(rowsToSend)
                });

                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(errorResponse.message || `Lỗi HTTP! status: ${response.status}`);
                }

                const json = await response.json();

                if (json.success) {
                    removeToast(loadingToast);
                    showCustomAlert(`Cập nhật thành công ${json?.updated + ' đơn hàng từ dữ liệu đã dán!'} `, 'success');

                    // Cập nhật lại state.allData và xóa các thay đổi đã thành công khỏi pendingChanges
                    json.details.forEach(detail => {
                        if (detail.status === 'updated') {
                            const updatedRowData = rowsToSend.find(r => r[PRIMARY_KEY_COLUMN] === detail.primaryKey);
                            if (updatedRowData) {
                                // Cập nhật state.allData
                                const index = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === updatedRowData[PRIMARY_KEY_COLUMN]);
                                if (index !== -1) {
                                    state.allData[index] = { ...state.allData[index], ...updatedRowData };
                                }

                                // Xóa các thay đổi tương ứng khỏi pendingChanges
                                const orderChanges = state.pendingChanges.get(updatedRowData[PRIMARY_KEY_COLUMN]);
                                if (orderChanges) {
                                    Object.keys(updatedRowData).forEach(colName => {
                                        if (colName !== PRIMARY_KEY_COLUMN) {
                                            orderChanges.delete(colName);
                                        }
                                    });
                                    if (orderChanges.size === 0) {
                                        state.pendingChanges.delete(updatedRowData[PRIMARY_KEY_COLUMN]);
                                    }
                                }
                            }
                        }
                    });

                    savePendingChangesToLocalStorage();
                    render(); // Vẽ lại giao diện để xóa highlight khỏi các ô đã cập nhật thành công
                } else {
                    removeToast(loadingToast);
                    showCustomAlert(`Lỗi cập nhật hàng loạt: ${json.message || 'Lỗi không xác định.'}`, 'error');
                }

            } catch (error) {
                console.error('Lỗi khi cập nhật hàng loạt từ paste:', error);
                removeToast(loadingToast);
                showCustomAlert(`Lỗi kết nối: ${error.message}`, 'error');
            } finally {
                updateBtn.disabled = false;
            }
        }

        function toggleTrackingView() {
            state.showTrackingOrders = !state.showTrackingOrders;
            const btn = document.getElementById('toggleTrackingView');
            if (state.showTrackingOrders) {
                btn.textContent = 'Xem đơn không có mã Tracking';
                btn.classList.add('active');
            } else {
                btn.textContent = 'Xem đơn có mã Tracking';
                btn.classList.remove('active');
            }
            render();
        }

        function getCellValue(cell) {
            if (!cell) return '';
            const select = cell.querySelector('select');
            if (select) return select.value;
            const input = cell.querySelector('input');
            return input ? input.value : cell.textContent;
        }

        // ===== BẮT ĐẦU PHẦN SỬA LỖI (và di chuyển clearAllSelections ra ngoài) =====
        function setCellValue(cell, value) {
            if (!cell) return;
            const select = cell.querySelector('select');
            if (select) {
                select.value = value;
                select.dispatchEvent(new Event('change', { bubbles: true }));
                return;
            }
            const input = cell.querySelector('input');
            if (input) {
                    input.value = value;
                    input.dispatchEvent(new Event('blur', { bubbles: true })); // Trigger blur to save
                return;
            }
            if (cell.isContentEditable) {
                cell.textContent = value;
                cell.dispatchEvent(new Event('blur', { bubbles: true })); // Trigger blur to save
            }
        }

        // --- GLOBAL UTILITY FUNCTIONS ---
        // Di chuyển clearAllSelections ra khỏi setupInteractionHandlers để có thể gọi từ transferSelectedOrders
        function clearAllSelections() {
            document.querySelectorAll('td.cell-selected').forEach(c => c.classList.remove('cell-selected'));
            if (pasteAnchorCell) {
                pasteAnchorCell.classList.remove('paste-anchor');
                pasteAnchorCell = null;
            }
            updateSelectionSummary();
        }
        // ===== KẾT THÚC PHẦN SỬA LỖI =====

        function updateSelectionSummary() {
            const summaryEl = document.getElementById('selectionSummary');
            const transferBtn = document.getElementById('transferWarehouseBtn');
            const selectedCells = document.querySelectorAll('td.cell-selected');
            summaryEl.innerHTML = '';

            const selectedOrderIds = new Set();
            const orderIdColIndex = displayColumns.indexOf(PRIMARY_KEY_COLUMN);

            if (selectedCells.length === 0) {
                transferBtn.style.display = 'none';
                transferBtn.disabled = true;
                return;
            }

            const numericKeywords = ["số lượng", "giá", "tiền", "phí", "zipcode"];
            const columns = new Map();
            selectedCells.forEach(cell => {
                const colIndex = cell.cellIndex;
                if (colIndex === orderIdColIndex) {
                    const orderId = getCellValue(cell).trim();
                    if (orderId) {
                        selectedOrderIds.add(orderId);
                    }
                }

                if (!columns.has(colIndex)) {
                    columns.set(colIndex, []);
                }
                columns.get(colIndex).push(cell);
            });

            const summaryParts = [];
            columns.forEach((cells, colIndex) => {
                const headerText = displayColumns[colIndex].toLowerCase();
                const isNumeric = numericKeywords.some(kw => headerText.includes(kw));
                if (isNumeric) {
                    let sum = 0;
                    let count = 0;
                    cells.forEach(cell => {
                        const value = getCellValue(cell);
                        const num = parseFloat(String(value).replace(/[^\d.-]/g, ''));
                        if (!isNaN(num)) { sum += num; count++; }
                    });
                    if (count > 0) {
                        summaryParts.push(`<span class="summary-item">${displayColumns[colIndex]} | Sum: <b>${sum.toLocaleString('vi-VN')}</b></span>`);
                    }
                } else {
                    let count = 0;
                    cells.forEach(cell => {
                        if (getCellValue(cell).trim() !== '') { count++; }
                    });
                    if (count > 0) {
                        summaryParts.push(`<span class="summary-item">${displayColumns[colIndex]} | Count: <b>${count}</b></span>`);
                    }
                }
            });
            summaryEl.innerHTML = summaryParts.join('');

            if (selectedOrderIds.size > 0) {
                transferBtn.style.display = 'block';
                transferBtn.disabled = false;
            } else {
                transferBtn.style.display = 'none';
                transferBtn.disabled = true;
            }
        }

        // --- HÀM MỚI: XỬ LÝ CHUYỂN KHO ---
        async function transferSelectedOrders() {
            const transferBtn = document.getElementById('transferWarehouseBtn');
            const originalText = transferBtn.textContent;
            transferBtn.disabled = true;
            transferBtn.textContent = 'Đang chuyển...';
            const loadingToast = showCustomAlert('Đang chuyển kho...', 'info', 0); // Persistent alert

            const selectedOrderIds = new Set();
            const orderIdColIndex = displayColumns.indexOf(PRIMARY_KEY_COLUMN);
            document.querySelectorAll('td.cell-selected').forEach(cell => {
                if (cell.cellIndex === orderIdColIndex) {
                    const orderId = getCellValue(cell).trim();
                    if (orderId) {
                        selectedOrderIds.add({
                            "Mã đơn hàng": orderId
                        });
                    }
                }
            });

            if (selectedOrderIds.size === 0) {
                removeToast(loadingToast); // Dismiss loading toast
                showCustomAlert('Vui lòng chọn ít nhất một "Mã đơn hàng" để chuyển kho.', 'info');
                transferBtn.disabled = false;
                transferBtn.textContent = originalText;
                return;
            }

            const maDonList = Array.from(selectedOrderIds);

            try {
                const response = await fetch(TRANSFER_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ rows: maDonList })
                });

                if (!response.ok) {
                    const errorResponse = await response.json(); // Attempt to parse JSON error
                    throw new Error(errorResponse.message || `Lỗi HTTP! status: ${response.status}`);
                }

                const result = await response.json();

                if (result && result.success) {
                    clearAllSelections();
                    removeToast(loadingToast); // Dismiss loading toast
                    showCustomAlert('Chuyển kho thành công!', 'success', 2000);

                    // IMPORTANT: Re-fetch MGT Nội Bộ order list and re-render the table
                    // This ensures the 'MGT nội bộ' tab immediately reflects the changes.
                    // We re-fetch regardless of the current tab to keep the internal state consistent.
                    await fetchMGTNoiBoOrder(); // Re-fetch the ordered list for MGT nội bộ
                    render(); // Re-render the current view
                } else {
                    removeToast(loadingToast); // Dismiss loading toast
                    showCustomAlert(`Chuyển kho không thành công: ${result.message || 'Lỗi không xác định.'}`, 'error');
                }

            } catch (e) {
                console.error('Lỗi khi chuyển kho:', e);
                removeToast(loadingToast); // Dismiss loading toast
                showCustomAlert(`Lỗi kết nối hoặc xử lý: ${e.message}`, 'error');
            } finally {
                transferBtn.disabled = false;
                transferBtn.textContent = originalText;
                // This line is now redundant because `removeToast(loadingToast)` handles it.
                // const currentAlertMessage = document.getElementById('customAlertMessage').textContent;
                // if (document.getElementById('customAlert').classList.contains('show') &&
                //     currentAlertMessage === 'Đang chuyển kho...') {
                //     document.getElementById('customAlert').classList.remove('show');
                // }
            }
        }

        function setupInteractionHandlers() {
            const tableBody = document.getElementById('tableBody'); if (!tableBody) return;
            let isSelecting = false, startCell = null;
            const selectCells = (start, end) => { clearAllSelections(); const tableRows = tableBody.rows; const minRow = Math.min(start.parentElement.rowIndex, end.parentElement.rowIndex); const maxRow = Math.max(start.parentElement.rowIndex, end.parentElement.rowIndex); const minCol = Math.min(start.cellIndex, end.cellIndex); const maxCol = Math.max(start.cellIndex, end.cellIndex); for (let i = 0; i < tableRows.length; i++) { const row = tableRows[i]; if (row.rowIndex >= minRow && row.rowIndex <= maxRow) { for (let j = minCol; j <= maxCol; j++) { if (row.cells[j]) row.cells[j].classList.add('cell-selected'); } } } if (start) { pasteAnchorCell = start; start.classList.add('paste-anchor'); } };
            tableBody.addEventListener('mousedown', e => { if (e.button !== 0) return; const cell = e.target.closest('td'); if (!cell) return; e.preventDefault(); if (e.shiftKey && pasteAnchorCell) { selectCells(pasteAnchorCell, cell); updateSelectionSummary(); } else { isSelecting = true; clearAllSelections(); startCell = cell; pasteAnchorCell = cell; cell.classList.add('cell-selected'); cell.classList.add('paste-anchor'); updateSelectionSummary(); } });
            tableBody.addEventListener('mousemove', e => { if (!isSelecting || !startCell) return; const currentCell = e.target.closest('td'); if (currentCell && currentCell !== startCell) { selectCells(startCell, currentCell); } });
            document.addEventListener('mouseup', () => { if (isSelecting) { isSelecting = false; updateSelectionSummary(); } });
            tableBody.addEventListener('dblclick', e => { const cell = e.target.closest('td.editable'); if (!cell) return; const input = cell.querySelector('input, select'); if (input) { input.focus(); } else if (cell.isContentEditable) { cell.focus(); document.execCommand('selectAll', false, null); document.getSelection().collapseToEnd(); } });
            document.addEventListener('copy', e => { const selectedCells = document.querySelectorAll('td.cell-selected'); if (selectedCells.length === 0) return; e.preventDefault(); const rows = new Map(); selectedCells.forEach(cell => { const rowIndex = cell.parentElement.rowIndex; if (!rows.has(rowIndex)) rows.set(rowIndex, []); rows.get(rowIndex).push({ colIndex: cell.cellIndex, text: getCellValue(cell) }); }); const sortedRows = [...rows.entries()].sort((a, b) => a[0] - b[0]); const copyText = sortedRows.map(([, cells]) => cells.sort((a, b) => a.colIndex - b[0]).map(cell => cell.text).join('\t')).join('\n'); e.clipboardData.setData('text/plain', copyText); showCustomAlert(`Đã sao chép ${selectedCells.length} ô.`, 'info', 2000); });
            
            // === UPDATED PASTE LOGIC FOR BATCH UPDATE ===
            document.addEventListener('paste', e => {
                const activeEl = document.activeElement;
                if (activeEl && (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) || activeEl.isContentEditable)) {
                    return; // Bỏ qua nếu đang paste vào một input/textarea
                }
                if (!pasteAnchorCell) return;

                e.preventDefault();
                const pasteData = e.clipboardData.getData('text/plain');
                if (!pasteData) return;

                const pastedRows = pasteData.split(/[\r\n]+/).map(row => row.split('\t')).filter(row => row.length > 0 && !(row.length === 1 && row[0] === ''));
                if (pastedRows.length === 0) return;

                // Trường hợp 1: Dán một giá trị duy nhất vào nhiều ô đã chọn
                if (pastedRows.length === 1 && pastedRows[0].length === 1) {
                    const singleValue = pastedRows[0][0];
                    const editableSelected = document.querySelectorAll('td.cell-selected.editable');
                    if (editableSelected.length > 0) {
                        // Logic này không cần gọi API hàng loạt vì nó chỉ là 1 giá trị
                        editableSelected.forEach(cell => setCellValue(cell, singleValue));
                        showCustomAlert(`Đã dán giá trị vào ${editableSelected.length} ô.`, 'success', 2000);
                        updateSelectionSummary();
                        return;
                    }
                }

                // Trường hợp 2: Dán nhiều giá trị (dạng bảng)
                const tableRows = Array.from(document.getElementById('tableBody').rows);
                let startRowIndex = tableRows.findIndex(row => row.rowIndex === pasteAnchorCell.parentElement.rowIndex);
                let startColIndex = pasteAnchorCell.cellIndex;
                if (startRowIndex < 0 || startColIndex < 0) return;

                const changesForBatchUpdate = new Map(); // Dùng Map để gom các thay đổi theo orderId

                isPasting = true; // BẬT cờ báo hiệu đang dán

                pastedRows.forEach((rowData, i) => {
                    const targetRow = tableRows[startRowIndex + i];
                    if (!targetRow) return;

                    const orderId = targetRow.dataset.orderId;
                    if (!orderId) return; // Bỏ qua nếu dòng không có orderId

                    if (!changesForBatchUpdate.has(orderId)) {
                        changesForBatchUpdate.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId });
                    }

                    rowData.forEach((cellData, j) => {
                        const targetCell = targetRow.cells[startColIndex + j];
                        if (targetCell && targetCell.classList.contains('editable')) {
                            // Lấy dataKey (tên cột) để gửi API
                            const colName = displayColumns[startColIndex + j];
                            const dataKey = columnMapping[colName] || colName;

                            // Cập nhật giá trị trên UI. Thao tác này sẽ kích hoạt handleCellChange,
                            // nhưng vì isPasting=true nên nó sẽ không gọi API đơn lẻ.
                            setCellValue(targetCell, cellData);

                            // Lưu thay đổi để chuẩn bị cho việc gọi API hàng loạt
                            let valueForApi = cellData;
                            // Xử lý định dạng ngày tháng đặc biệt
                            if (colName === "Ngày đóng hàng") {
                                valueForApi = parseDateToISO(cellData);
                            }
                            changesForBatchUpdate.get(orderId)[dataKey] = valueForApi;
                        }
                    });
                });

                isPasting = false; // TẮT cờ sau khi đã cập nhật xong UI

                // Chuyển Map thành mảng để gửi đi
                const rowsToSend = Array.from(changesForBatchUpdate.values());

                // Gọi hàm cập nhật hàng loạt với những thay đổi vừa thu thập
                if (rowsToSend.length > 0) {
                    batchUpdatePastedData(rowsToSend);
                }

                showCustomAlert(`Đã dán ${pastedRows.length} dòng dữ liệu.`, 'success', 2000);
                updateSelectionSummary();
            });

            document.addEventListener('keydown', e => {
                const activeEl = document.activeElement; if (activeEl && (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) || activeEl.isContentEditable)) { return; }
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const editableSelected = document.querySelectorAll('td.cell-selected.editable');
                    if (editableSelected.length > 0) { e.preventDefault(); editableSelected.forEach(cell => { setCellValue(cell, ''); }); if (editableSelected.length > 1) { showCustomAlert(`Đã xóa nội dung của ${editableSelected.length} ô.`, 'success', 2000); } updateSelectionSummary(); }
                }
            });
        }

        // --- HÀM TẢI FILE EXCEL (CSV) ---
        function downloadAsExcel() {
            // Get ALL filtered data for export, by re-applying the filtering logic WITHOUT pagination.
            const allFilteredData = (function () {
                // --- Bắt đầu sao chép logic lọc từ getFilteredData ---
                const mergedData = state.allData.map(originalRow => {
                    const orderId = originalRow[PRIMARY_KEY_COLUMN];
                    const changes = state.pendingChanges.get(orderId);
                    if (changes) {
                        const changeObject = {};
                        changes.forEach((changeInfo, key) => { changeObject[key] = changeInfo.newValue; });
                        return { ...originalRow, ...changeObject };
                    }
                    return originalRow;
                });

                const mgtData = filterByCarrier(mergedData);

                let dataToExport = mgtData.filter(row => {
                    const trackingCode = String(row["Mã Tracking"] || row["Mã_Tracking"] || '');
                    return state.showTrackingOrders ? trackingCode.trim() !== '' : !trackingCode.trim();
                });

                const market = document.getElementById('filterMarket').value;
                const product = document.getElementById('filterProduct').value;
                const dateFrom = document.getElementById('filterDateFrom').value;
                const dateTo = document.getElementById('filterDateTo').value;

                if (market) { dataToExport = dataToExport.filter(row => row["Khu vực"] === market); }
                if (product) { dataToExport = dataToExport.filter(row => row["Mặt hàng"] === product); }
                if (dateFrom) { const from = new Date(dateFrom); from.setHours(0, 0, 0, 0); dataToExport = dataToExport.filter(row => row["Ngày lên đơn"] && new Date(row["Ngày lên đơn"]) >= from); }
                if (dateTo) { const to = new Date(dateTo); to.setHours(23, 59, 59, 999); dataToExport = dataToExport.filter(row => row["Ngày lên đơn"] && new Date(row["Ngày lên đơn"]) <= to); }

                if (state.activeTeam === 'mgt_noi_bo') {
                    if (state.mgtNoiBoOrder.length > 0) {
                        const orderedIds = new Set(state.mgtNoiBoOrder);
                        dataToExport = dataToExport.filter(row => orderedIds.has(row["Mã đơn hàng"]));
                        const orderIndexMap = new Map(state.mgtNoiBoOrder.map((id, index) => [id, index]));
                        dataToExport.sort((a, b) => {
                            const indexA = orderIndexMap.get(a[PRIMARY_KEY_COLUMN]);
                            const indexB = orderIndexMap.get(b[PRIMARY_KEY_COLUMN]);
                            return indexA - indexB;
                        });
                    }
                } else if (state.activeTeam !== 'all') {
                    dataToExport = dataToExport.filter(row => row[TEAM_COLUMN_NAME] === state.activeTeam);
                }

                const trackingIncludeRaw = state.filterValues['tracking_include'] || '';
                const trackingExcludeRaw = state.filterValues['tracking_exclude'] || '';
                const otherColumnFilters = Object.entries(state.filterValues).filter(([key, val]) => val.trim() !== '' && !key.startsWith('tracking_'));

                if (otherColumnFilters.length > 0) {
                    dataToExport = dataToExport.filter(row => {
                        return otherColumnFilters.every(([col, filterValue]) => {
                            const dataKey = columnMapping[col] || col;
                            const cellValue = row[dataKey] ?? row[col] ?? row[dataKey.replace(/ /g, '_')] ?? '';
                            return String(cellValue).toLowerCase().includes(filterValue.toLowerCase());
                        });
                    });
                }

                if (trackingIncludeRaw || trackingExcludeRaw) {
                    const lowerInclude = trackingIncludeRaw.toLowerCase();
                    const lowerExclude = trackingExcludeRaw.toLowerCase();
                    dataToExport = dataToExport.filter(row => {
                        const cellValue = String(row['Mã Tracking'] || '');
                        const lowerCellValue = cellValue.toLowerCase();
                        if (lowerExclude && lowerCellValue.includes(lowerExclude)) { return false; }
                        if (lowerInclude) {
                            if (lowerInclude.includes('\n')) {
                                const codes = new Set(trackingIncludeRaw.split('\n').map(t => t.trim()).filter(Boolean));
                                if (!codes.has(cellValue.trim())) return false;
                            } else {
                                if (!lowerCellValue.includes(lowerInclude)) return false;
                            }
                        }
                        return true;
                    });
                }

                if (state.activeTeam !== 'mgt_noi_bo') {
                    const primarySortKey = 'Ngày Kế toán đối soát với FFM lần 2';
                    const secondarySortKey = PRIMARY_KEY_COLUMN;
                    dataToExport.sort((a, b) => {
                        const parseDate = (val) => { if (!val) return null; const date = new Date(val); return isNaN(date.getTime()) ? null : date; };
                        const dateA = parseDate(a[primarySortKey]);
                        const dateB = parseDate(b[primarySortKey]);
                        if (dateA === null && dateB === null) { }
                        else if (dateA === null) { return 1; }
                        else if (dateB === null) { return -1; }
                        else { const dateComparison = dateA.getTime() - dateB.getTime(); if (dateComparison !== 0) { return dateComparison; } }
                        const orderIdA = a[secondarySortKey] || '';
                        const orderIdB = b[secondarySortKey] || '';
                        return orderIdA.localeCompare(orderIdB);
                    });
                }
                // --- Kết thúc sao chép logic lọc ---

                return dataToExport; // Trả về dữ liệu đã lọc mà không phân trang
            })();


            if (allFilteredData.length === 0) { showCustomAlert("Không có dữ liệu để tải về.", 'info'); return; }

            // Phần còn lại của hàm giữ nguyên
            const sanitizeCsvCell = (cell, colName) => {
                if (cell === null || cell === undefined) return '';
                let str = String(cell);
                if ((colName === "Mã Tracking" || colName === "Phone*") && str) {
                    return `="${str.replace(/"/g, '""')}"`;
                }
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    str = str.replace(/"/g, '""');
                    return `"${str}"`;
                }
                return str;
            };
            const headers = displayColumns.map(col => sanitizeCsvCell(col, col)).join(',');
            const rows = allFilteredData.map(row => {
                return displayColumns.map(col => {
                    const dataKey = columnMapping[col] || col;
                    let value = row[dataKey] ?? row[col] ?? row[col.replace(/ /g, '_')] ?? '';
                    if (["Ngày lên đơn", "Ngày đóng hàng"].includes(col)) {
                        value = formatDate(value);
                    }
                    return sanitizeCsvCell(value, col);
                }).join(',');
            }).join('\n');
            const BOM = '\uFEFF'; const csvContent = BOM + headers + '\n' + rows;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) { const url = URL.createObjectURL(blob); const today = new Date(); const dateStr = `${today.getFullYear()}${(today.getMonth() + 1).toString().padStart(2, '0')}${today.getDate().toString().padStart(2, '0')}`; link.setAttribute("href", url); link.setAttribute("download", `BaoCaoDonHang_MGT_${dateStr}.csv`); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); }
        }

        // --- KHỞI TAO ---
        document.addEventListener('DOMContentLoaded', () => {
            loadPendingChangesFromLocalStorage(); // Load pending changes early
            setupControls();
            setupInteractionHandlers();

            // NEW: Set initial rows per page from select element
            const rowsPerPageSelect = document.getElementById('rowsPerPageSelect');
            state.rowsPerPage = parseInt(rowsPerPageSelect.value, 10);

            refreshData(); // Initial data load
        });
    </script>
</body>

</html>

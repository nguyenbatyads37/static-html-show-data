<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>QU·∫¢N L√ù V·∫¨N ƒê∆†N LumiGlobal</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    :root {
      --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      --primary-color: #1D2F5F;
      --primary-color-dark: #16254A;
      --primary-color-light: #E8EAF6;
      --accent-color: #F37021;
      --accent-color-dark: #D85B0A;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
      --text-color: #212529;
      --text-color-muted: #6c757d;
      --bg-body: #f8f9fa;
      --bg-card: #ffffff;
      --border-color: #dee2e6;
      --border-radius: 6px;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --transition-speed: 0.2s;
    }

    html {
      font-size: 16px;
    }

    body {
      font-family: var(--font-family);
      padding: 20px;
      background-color: var(--bg-body);
      color: var(--text-color);
      margin: 0;
      line-height: 1.5;
    }

    .page-header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      margin-bottom: 2rem;
    }

    .header-logo {
      height: 50px;
      width: auto;
      mix-blend-mode: darken;
    }

    h2 {
      margin: 0;
      color: var(--accent-color);
      font-weight: 700;
      text-transform: uppercase;
      font-size: 1.75rem;
    }

    #loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.3s ease;
    }

    #loader-overlay img {
      max-width: 200px;
      animation: pulse 1.5s infinite ease-in-out;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.05);
        opacity: 0.8;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes pulse-glow {
      0% {
        box-shadow: 0 0 5px rgba(243, 112, 33, 0.5);
      }

      50% {
        box-shadow: 0 0 15px rgba(243, 112, 33, 0.8), 0 0 25px rgba(243, 112, 33, 0.3);
      }

      100% {
        box-shadow: 0 0 5px rgba(243, 112, 33, 0.5);
      }
    }

    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-card);
      padding: 1rem 1.5rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-md);
      position: sticky;
      top: 0;
      z-index: 100;
      flex-wrap: wrap;
      gap: 1rem;
      border: 1px solid var(--border-color);
      margin-bottom: 1.5rem;
    }

    .controls .left-controls,
    .controls .right-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    button,
    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      font-weight: 500;
      color: white;
      transition: all var(--transition-speed) ease-in-out;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
    }

    button:hover,
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    button:focus-visible,
    .btn:focus-visible {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }

    .refresh-btn {
      background-color: var(--success-color);
    }

    .update-btn {
      background-color: var(--primary-color);
    }

    .clear-filter-btn {
      background-color: var(--warning-color);
      color: var(--text-color);
    }

    .refresh-btn:hover {
      background-color: #218838;
    }

    .update-btn:hover {
      background-color: var(--primary-color-dark);
    }

    .clear-filter-btn:hover {
      background-color: #e0a800;
    }

    input[type="text"],
    input[type="date"],
    input[type="number"],
    select,
    .filter-select {
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      background-color: var(--bg-card);
      transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(29, 47, 95, 0.25);
    }

    .tab-controls {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 1.5rem;
      margin-left: 0;
      padding: 0;
      border-radius: 0;
      overflow: visible;
    }

    .tab-btn {
      background-color: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-color-muted);
      border-radius: 0;
      margin-bottom: -2px;
      box-shadow: none;
    }

    .tab-btn:hover {
      color: var(--accent-color);
      background-color: #fef0e8;
      transform: none;
      box-shadow: none;
    }

    .tab-btn.active {
      color: var(--accent-color);
      background-color: transparent;
      border-color: var(--accent-color);
      box-shadow: none;
    }

    .content-tab {
      display: none;
    }

    .content-tab.active {
      display: block;
    }

    .main-table-wrapper {
      overflow: auto;
      max-height: calc(100vh - 250px);
      background: var(--bg-card);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border-color);
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 2200px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    th,
    td {
      border: none;
      border-bottom: 1px solid var(--border-color);
      padding: 0.75rem 1rem;
      white-space: nowrap;
      background-color: var(--bg-card);
      text-align: left;
    }

    th {
      background-color: #f8f9fa;
      color: var(--text-color);
      font-weight: 600;
      vertical-align: top;
      position: sticky;
      top: 0;
      z-index: 20;
      border-bottom-width: 2px;
    }

    #tableBody tr:hover td,
    #japanTableBody tr:hover td,
    #leaderTableBody tr:hover td,
    #mentionedTableBody tr:hover td,
    #hcmTableBody tr:hover td,
    #hanoiTableBody tr:hover td {
      /* Th√™m ID m·ªõi */
      background-color: var(--primary-color-light) !important;
      cursor: pointer;
    }

    th .filter-input,
    th .filter-select {
      width: 100%;
      box-sizing: border-box;
      margin-top: 0.5rem;
      padding: 0.3rem 0.5rem;
      font-size: 0.75rem;
    }

    th .tracking-filter-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 0.5rem;
    }

    th .tracking-filter-container input {
      width: 100%;
      box-sizing: border-box;
    }

    .multi-select-container {
      position: relative;
      display: inline-block;
      width: 100%;
      margin-top: 0.5rem;
    }

    .multi-select-container .multi-select-button {
      background-color: var(--bg-card);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      font-size: 0.75rem;
      padding: 0.3rem 0.5rem;
      text-align: left;
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-radius: var(--border-radius);
      cursor: pointer;
    }

    .multi-select-container .multi-select-button:hover {
      border-color: var(--secondary-color);
    }

    .checkbox-dropdown {
      display: none;
      position: absolute;
      background-color: var(--bg-card);
      min-width: 220px;
      box-shadow: var(--shadow-lg);
      z-index: 101;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      max-height: 250px;
      overflow-y: auto;
      padding: 0.5rem;
      margin-top: 4px;
    }

    .checkbox-dropdown.show {
      display: block;
    }

    .checkbox-dropdown label {
      display: flex;
      align-items: center;
      padding: 0.4rem 0.6rem;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color var(--transition-speed);
      white-space: nowrap;
      font-size: 0.8rem;
      color: var(--text-color);
      font-weight: 400;
    }

    .checkbox-dropdown label:hover {
      background-color: #e9ecef;
    }

    .checkbox-dropdown label input {
      margin-right: 0.5rem;
    }

    .controls .checkbox-dropdown {
      font-size: 1rem;
    }

    .controls .checkbox-dropdown label {
      font-size: 0.9rem;
    }

    .fixed-column {
      position: sticky;
      z-index: 5;
    }

    th.fixed-column {
      z-index: 30;
      background-color: #f1f3f5;
    }

    td.fixed-column {
      background-color: #f8f9fa;
      border-right: 1px solid var(--border-color);
    }

    td.editable {
      background-color: #e8f5e9;
      border-left: 3px solid #66bb6a;
    }

    .summary-info {
      background: var(--primary-color-light);
      padding: 0.5rem 1rem;
      border-radius: var(--border-radius);
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--primary-color-dark);
      border: 1px solid #c9d1e9;
    }

    .cell-selected {
      background-color: #a7ffeb !important;
      outline: 2px solid #00bfa5;
      outline-offset: -2px;
    }

    .cell-ok {
      background-color: #d4edda !important;
    }

    .cell-cancel {
      background-color: #f8d7da !important;
    }

    .cell-xl {
      background-color: #fff3cd !important;
    }

    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    ::-webkit-scrollbar-thumb {
      background-color: var(--primary-color);
      border-radius: 10px;
      border: 3px solid #f1f1f1;
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: var(--primary-color-dark);
    }

    .controls .multi-select-container button {
      background-color: white;
      color: #333;
      border: 1px solid #ccc;
      font-size: 0.9rem;
      padding: 0.5rem 0.75rem;
      text-align: left;
      width: 250px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .controls .checkbox-dropdown {
      min-width: 250px;
      max-height: 300px;
      padding: 10px;
    }

    .controls .checkbox-dropdown label {
      padding: 8px 12px;
      font-size: 16px;
      font-weight: normal;
      color: #333;
    }

    .controls .checkbox-dropdown label input {
      margin-right: 10px;
    }

    .status {
      font-size: 0.85em;
      margin-left: 8px;
      color: var(--success-color);
    }

    .error-status {
      color: var(--danger-color);
    }

    td.highlight {
      background-color: #ffeb3b !important;
    }

    /* === NEW POPOVER STYLES === */
    .popover-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .popover-content {
      background: white;
      padding: 20px;
      border-radius: var(--border-radius);
      width: 90%;
      max-width: 600px;
      box-shadow: var(--shadow-lg);
      display: flex;
      flex-direction: column;
    }

    .popover-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    .popover-header h3 {
      margin: 0;
      color: var(--primary-color);
    }

    .close-popover {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-color-muted);
    }

    .popover-body {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 20px;
    }

    .popover-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      border-top: 1px solid var(--border-color);
      padding-top: 15px;
    }

    .pending-change-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      font-size: 0.9rem;
    }

    .pending-change-item:last-child {
      border-bottom: none;
    }

    .pending-change-item strong {
      color: var(--primary-color-dark);
    }

    .pending-change-item ul {
      margin-top: 5px;
      padding-left: 20px;
    }

    /* Badge for status button */
    #pending-count-badge {
      background-color: white;
      color: var(--accent-color);
      border-radius: 50%;
      padding: 2px 6px;
      font-size: 0.75em;
      font-weight: bold;
      vertical-align: top;
      margin-left: 5px;
      min-width: 18px;
      text-align: center;
      border: 2px solid var(--accent-color);
    }

    #update-info {
      font-size: 0.85em;
      font-weight: 500;
      margin-left: 5px;
    }

    #pending-count-text {
      font-weight: bold;
      color: inherit;
    }

    /* D√°n ƒëo·∫°n CSS n√†y v√†o cu·ªëi th·∫ª <style> c·ªßa b·∫°n */

    td.long-text-cell {
      max-width: 250px;
      /* Chi·ªÅu r·ªông m·∫∑c ƒë·ªãnh cho c·ªôt */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: top;
      /* CƒÉn n·ªôi dung l√™n tr√™n ƒë·ªÉ d·ªÖ nh√¨n h∆°n */
      cursor: pointer;
    }

    td.long-text-cell.expanded {
      white-space: pre-wrap;
      /* Cho ph√©p xu·ªëng d√≤ng v√† bao b·ªçc vƒÉn b·∫£n */
      text-overflow: clip;
      overflow: visible;
      position: relative;
      z-index: 10;
      /* ƒê·∫£m b·∫£o n·ªôi dung m·ªü r·ªông kh√¥ng b·ªã che */
      background-color: #feffde !important;
      /* ƒê·ªïi m√†u n·ªÅn ƒë·ªÉ l√†m n·ªïi b·∫≠t √¥ ƒëang m·ªü r·ªông */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      /* Th√™m b√≥ng ƒë·ªï nh·∫π */
    }
  </style>
</head>

<body>

  <div id="loader-overlay">
    <img
      src="https://www.appsheet.com/template/gettablefileurl?appName=Appsheet-325045268&tableName=Kho%20%E1%BA%A3nh&fileName=Kho%20%E1%BA%A3nh_Images%2Ff930e667.%E1%BA%A2nh.025539.jpg"
      alt="Loading Logo">
  </div>

  <div class="page-header">
    <img class="header-logo"
      src="https://www.appsheet.com/template/gettablefileurl?appName=Appsheet-325045268&tableName=Kho%20%E1%BA%A3nh&fileName=Kho%20%E1%BA%A3nh_Images%2Ff930e667.%E1%BA%A2nh.025539.jpg"
      alt="LumiGlobal Logo">
    <h2>QU·∫¢N L√ù V·∫¨N ƒê∆†N LumiGlobal</h2>
  </div>

  <div class="tab-controls">
    <button id="tabData" class="tab-btn active">D·ªØ li·ªáu ƒë∆°n h√†ng</button>
    <button id="tabLeader" class="tab-btn" style="display: none;">ƒê∆°n c·ªßa Leader</button>
    <button id="tabJapan" class="tab-btn">ƒê∆°n Nh·∫≠t</button>
    <button id="tabMentioned" class="tab-btn" style="display: none;">Ng∆∞·ªùi ƒë∆∞·ª£c nh·∫Øc h·ªô</button>
    <!-- NEW TABS -->
    <button id="tabHCM" class="tab-btn" style="display: none;">FFM ƒë·∫©y v·∫≠n h√†nh</button>
    <button id="tabHanoi" class="tab-btn" style="display: none;">FFM H√† N·ªôi</button>
  </div>

  <div id="contentData" class="content-tab active">
    <div class="controls">
      <div class="left-controls">
        <span id="userInfo"></span>
        <button id="refreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="updateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <!-- NEW STATUS BUTTON -->
        <button id="statusButton" class="status-btn" style="background-color: #6c757d;">
          Tr·∫°ng th√°i c·∫≠p nh·∫≠t
          <span id="update-info">
            (<span id="pending-count-text">0</span> b·∫£n c·∫≠p nh·∫≠t)
          </span>
          <span id="pending-count-badge">0</span>
        </button>
        <div class="fixed-col-control">
          <span>C·ªôt c·ªë ƒë·ªãnh:</span>
          <input type="number" id="fixedColumnCountInput" value="1" min="0" style="width: 70px;">
        </div>
        <div id="summaryInfo" class="summary-info"></div>
        <div id="selectionSummary" class="summary-info" style="background-color: #e8f5e9; border: 1px solid #a5d6a7;">
        </div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="startDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="endDateFilter" />
        </div>
        <select id="productFilter" class="filter-select">
          <option value="">T·∫•t c·∫£ s·∫£n ph·∫©m</option>
        </select>
        <select id="marketFilter" class="filter-select">
          <option value="">T·∫•t c·∫£ khu v·ª±c</option>
        </select>
        <button id="clearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="tableContainer">
      <table>
        <thead id="tableHead"></thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB LEADER -->
  <div id="contentLeader" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng do b·∫°n x·ª≠ l√Ω</span>
        <button id="leaderRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="leaderUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="leaderSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="leaderStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="leaderEndDateFilter" />
        </div>
        <select id="leaderProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <button id="leaderClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="leaderTableContainer">
      <table>
        <thead id="leaderTableHead"></thead>
        <tbody id="leaderTableBody"></tbody>
      </table>
    </div>
  </div>

  <div id="contentJapan" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng khu v·ª±c: Nh·∫≠t B·∫£n</span>
        <button id="japanRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="japanUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="japanSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="japanStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="japanEndDateFilter" />
        </div>
        <select id="japanProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <select id="japanStaffFilter" class="filter-select">
          <option value="">NV V·∫≠n ƒë∆°n</option>
        </select>
        <button id="japanClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="japanTableContainer">
      <table>
        <thead id="japanTableHead"></thead>
        <tbody id="japanTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB NG∆Ø·ªúI ƒê∆Ø·ª¢C NH·∫ÆC H·ªò M·ªöI -->
  <div id="contentMentioned" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng c·ªßa ng∆∞·ªùi ƒë∆∞·ª£c nh·∫Øc h·ªô</span>
        <button id="mentionedRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="mentionedUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="mentionedSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="mentionedStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="mentionedEndDateFilter" />
        </div>
        <select id="mentionedProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <button id="mentionedClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="mentionedTableContainer">
      <table>
        <thead id="mentionedTableHead"></thead>
        <tbody id="mentionedTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB HCM -->
  <div id="contentHCM" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng khu v·ª±c: H·ªì Ch√≠ Minh</span>
        <button id="hcmRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="hcmUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="hcmSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="hcmStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="hcmEndDateFilter" />
        </div>
        <select id="hcmProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <select id="hcmStaffFilter" class="filter-select">
          <option value="">NV V·∫≠n ƒë∆°n</option>
        </select>
        <button id="hcmClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="hcmTableContainer">
      <table>
        <thead id="hcmTableHead"></thead>
        <tbody id="hcmTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- N·ªòI DUNG TAB H√Ä N·ªòI -->
  <div id="contentHanoi" class="content-tab">
    <div class="controls">
      <div class="left-controls">
        <span class="tab-info-text">ƒê∆°n h√†ng khu v·ª±c: H√† N·ªôi</span>
        <button id="hanoiRefreshData" class="refresh-btn"><span class="refresh-icon">‚Üª</span> Load</button>
        <button id="hanoiUpdateAll" class="update-btn">C·∫≠p nh·∫≠t</button>
        <div id="hanoiSummaryInfo" class="summary-info"></div>
      </div>
      <div class="right-controls">
        <div class="date-filter">
          <span>T·ª´:</span><input type="date" id="hanoiStartDateFilter" />
          <span>ƒê·∫øn:</span><input type="date" id="hanoiEndDateFilter" />
        </div>
        <select id="hanoiMarketFilter" class="filter-select">
          <option value="">T·∫•t c·∫£ khu v·ª±c</option>
        </select>
        <select id="hanoiProductFilter" class="filter-select">
          <option value="">S·∫£n ph·∫©m</option>
        </select>
        <select id="hanoiStaffFilter" class="filter-select">
          <option value="">NV V·∫≠n ƒë∆°n</option>
        </select>
        <button id="hanoiClearFilters" class="clear-filter-btn">X√≥a l·ªçc</button>
      </div>
    </div>
    <div class="main-table-wrapper" id="hanoiTableContainer">
      <table>
        <thead id="hanoiTableHead"></thead>
        <tbody id="hanoiTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- NEW STATUS POPOVER HTML -->
  <div id="status-popover" class="popover-overlay" style="display: none;">
    <div class="popover-content">
      <div class="popover-header">
        <h3>C√°c thay ƒë·ªïi ƒëang ch·ªù</h3>
        <button class="close-popover">&times;</button>
      </div>
      <div id="pending-changes-list" class="popover-body">
        <!-- Changes will be listed here -->
      </div>
      <div class="popover-footer">
        <button id="cancel-all-changes" class="btn clear-filter-btn">H·ªßy t·∫•t c·∫£</button>
        <button id="update-all-pending" class="btn update-btn">C·∫≠p nh·∫≠t t·∫•t c·∫£</button>
      </div>
    </div>
  </div>
  <script>
    const prod = 'https://n-api-gamma.vercel.app';
    const localhost = 'http://localhost:8081';
    const host = 'prod';
    const mainHost = host === 'prod' ? prod : localhost;
    const SHEET_NAME = 'F3';
    const UPDATE_SINGLE_URL = `${mainHost}/sheet/${SHEET_NAME}/update-single`;
    const UPDATE_BULK_URL = `${mainHost}/sheet/${SHEET_NAME}/update`;
    const LOCAL_STORAGE_KEY = 'lumiglobal_pending_changes';


    // === C·∫§U H√åNH C·ªòT ===
    const columnDisplayMapping = {};
    const editableCols = ["K·∫øt qu·∫£ Check", "Tr·∫°ng th√°i giao h√†ng NB", "L√Ω do", "Tr·∫°ng th√°i thu ti·ªÅn", "Ghi ch√∫ c·ªßa Vƒê"];
    // === TH√äM 2 D√íNG N√ÄY ===
    const longTextColumns = ["L√Ω do", "Ghi ch√∫ c·ªßa Vƒê"]; // C√°c c·ªôt c·∫ßn √°p d·ª•ng
    let areLongTextFieldsExpanded = false; // Bi·∫øn l∆∞u tr·∫°ng th√°i
    // === K·∫æT TH√öC ===
    // === H√ÄM M·ªöI ƒê·ªÇ M·ªû R·ªòNG/THU G·ªåN TO√ÄN B·ªò C·ªòT ===
    function toggleAllLongTextCells(expand) {
      const activeTableBody = document.querySelector('.content-tab.active tbody');
      if (!activeTableBody) return;

      const targetColumnIndexes = displayColumns
        .map((colName, index) => (longTextColumns.includes(colName) ? index : -1))
        .filter(index => index !== -1);

      if (targetColumnIndexes.length === 0) return;

      activeTableBody.querySelectorAll('tr').forEach(row => {
        targetColumnIndexes.forEach(colIndex => {
          const cell = row.cells[colIndex];
          if (cell) {
            if (expand) {
              cell.classList.add('expanded');
            } else {
              cell.classList.remove('expanded');
            }
          }
        });
      });

      const activeTab = document.querySelector('.content-tab.active');
      if (activeTab) {
        const activeConfig = allTabConfigs.find(c => c.table.body === activeTab.querySelector('tbody')?.id);
        if (activeConfig) {
          setTimeout(() => updateStickyColumns(activeConfig), 50);
        }
      }
    }
    const dropdownCols = {
      "K·∫øt qu·∫£ Check": ["", "OK", "Hu·ª∑", "Treo", "V·∫≠n ƒë∆°n XL", "ƒê·ª£i h√†ng", "Kh√°ch h·∫πn"],
      "Tr·∫°ng th√°i giao h√†ng NB": ["", "Giao Th√†nh C√¥ng", "ƒêang Giao", "Ch∆∞a Giao", "H·ªßy", "Ho√†n", "ch·ªù check", "Giao kh√¥ng th√†nh c√¥ng", "Bom_Th·∫•t L·∫°c", "Ch∆∞a giao", "ch∆∞a giao"],
      "Tr·∫°ng th√°i thu ti·ªÅn": ["", "C√≥ bill", "C√≥ bill 1 ph·∫ßn", "Bom_b√πng_ch·∫∑n", "H·∫πn Thanh To√°n", "Ho√†n H√†ng", "Kh√≥ ƒê√≤i", "Kh√¥ng nh·∫≠n ƒë∆∞·ª£c h√†ng", "Kh√¥ng PH d∆∞·ªõi 3N", "Thanh to√°n ph√≠ ho√†n", "KPH nhi·ªÅu ng√†y"]
    };
    const displayColumns = ["M√£ ƒë∆°n h√†ng", "K·∫øt qu·∫£ Check", "Tr·∫°ng th√°i giao h√†ng NB", "M√£ Tracking", "L√Ω do", "Tr·∫°ng th√°i thu ti·ªÅn", "Ghi ch√∫ c·ªßa Vƒê", "Ng√†y l√™n ƒë∆°n", "Name*", "Phone*", "Add", "City", "State", "khu v·ª±c", "Zipcode", "M·∫∑t h√†ng", "T√™n m·∫∑t h√†ng 1", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 1", "T√™n m·∫∑t h√†ng 2", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 2", "Qu√† t·∫∑ng", "S·ªë l∆∞·ª£ng qu√† k√®m", "Gi√° b√°n", "Lo·∫°i ti·ªÅn thanh to√°n", "T·ªïng ti·ªÅn VNƒê", "H√¨nh th·ª©c thanh to√°n", "Ghi ch√∫", "Ng√†y ƒë√≥ng h√†ng", "Tr·∫°ng th√°i giao h√†ng", "Th·ªùi gian giao d·ª± ki·∫øn", "Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)", "Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)", "GHI CH√ö", "Nh√¢n vi√™n Sale", "NV V·∫≠n ƒë∆°n", "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn", "S·ªë ti·ªÅn c·ªßa ƒë∆°n h√†ng ƒë√£ v·ªÅ TK Cty", "K·∫ø to√°n x√°c nh·∫≠n thu ti·ªÅn v·ªÅ", "Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"];
    const allDateColumns = ["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"];
    const columnsToMakeDynamic = ["K·∫øt qu·∫£ Check", "Tr·∫°ng th√°i giao h√†ng NB", "Tr·∫°ng th√°i thu ti·ªÅn", "khu v·ª±c", "M·∫∑t h√†ng", "Nh√¢n vi√™n Sale", "NV V·∫≠n ƒë∆°n", "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"];

    const singleSelectFilterCols = [];
    const datalistFilterCols = ["M√£ ƒë∆°n h√†ng", "Name*", "Phone*", "Nh√¢n vi√™n Sale"];
    // === K·∫æT TH√öC C·∫§U H√åNH ===

    let allData = [],
      allStaffData = [], // Store all staff data here
      staffFilteredData = [],
      japanData = [],
      leaderData = [],
      mentionedData = [],
      hcmData = [],
      hanoiData = [],
      currentStaff = null,
      teamMembers = [],
      selectedCells = new Set(),
      isMouseDown = false,
      startCell = null,
      dynamicFilterOptions = {},
      japanDynamicFilterOptions = {},
      leaderDynamicFilterOptions = {},
      mentionedDynamicFilterOptions = {},
      hcmDynamicFilterOptions = {},
      hanoiDynamicFilterOptions = {},
      datalistOptions = {},
      filterDebounceTimer;


    // --- Local Storage & Status Popover Logic ---
    function updateStatusButtonUI() {
      const changes = getPendingChanges();
      const count = Object.keys(changes).length;
      const badge = document.getElementById('pending-count-badge');
      const countText = document.getElementById('pending-count-text');
      const updateInfo = document.getElementById('update-info');
      const statusButton = document.getElementById('statusButton');

      if (badge) {
        badge.textContent = count;
        badge.style.display = count > 0 ? '' : 'none';
      }

      if (countText) {
        countText.textContent = count;
      }

      if (updateInfo) {
        updateInfo.style.display = count > 0 ? '' : 'none';
      }

      if (statusButton) {
        statusButton.style.backgroundColor = count > 0 ? 'var(--accent-color)' : '#6c757d';
        // Add animation effect when there are updates
        if (count > 0) {
          statusButton.style.animation = 'pulse-glow 2s infinite';
        } else {
          statusButton.style.animation = 'none';
        }
      }
    }

    function showStatusPopover() {
      const popover = document.getElementById('status-popover');
      const listContainer = document.getElementById('pending-changes-list');
      const changes = getPendingChanges();
      const changeKeys = Object.keys(changes);

      listContainer.innerHTML = ''; // Clear previous list

      if (changeKeys.length === 0) {
        listContainer.innerHTML = '<p style="text-align: center; color: var(--text-color-muted);">Kh√¥ng c√≥ thay ƒë·ªïi n√†o ƒëang ch·ªù c·∫≠p nh·∫≠t.</p>';
      } else {
        changeKeys.forEach(primaryKey => {
          const changeData = changes[primaryKey];
          const itemDiv = document.createElement('div');
          itemDiv.className = 'pending-change-item';

          let changesHtml = `<strong>ƒê∆°n h√†ng: ${primaryKey}</strong><ul>`;
          for (const field in changeData) {
            if (field !== "M√£ ƒë∆°n h√†ng") {
              changesHtml += `<li>${field}: "<strong>${changeData[field]}</strong>"</li>`;
            }
          }
          changesHtml += '</ul>';
          itemDiv.innerHTML = changesHtml;
          listContainer.appendChild(itemDiv);
        });
      }
      popover.style.display = 'flex';
    }

    function hideStatusPopover() {
      document.getElementById('status-popover').style.display = 'none';
    }

    async function handleUpdateAllPending() {
      const payload = Object.values(getPendingChanges());

      if (payload.length === 0) {
        showTempMessage('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ c·∫≠p nh·∫≠t.', true);
        return;
      }

      const updateBtn = document.getElementById('update-all-pending');
      const originalText = updateBtn.textContent;
      updateBtn.disabled = true;
      updateBtn.textContent = 'ƒêang x·ª≠ l√Ω...';

      try {
        const response = await fetch(UPDATE_BULK_URL, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        // Ki·ªÉm tra xem response c√≥ h·ª£p l·ªá kh√¥ng (v√≠ d·ª•: l·ªói m·∫°ng, l·ªói server 500)
        if (!response.ok) {
          // C·ªë g·∫Øng ƒë·ªçc th√¥ng b√°o l·ªói t·ª´ server n·∫øu c√≥
          const errorResult = await response.json().catch(() => null);
          throw new Error(errorResult?.message || `L·ªói t·ª´ server: ${response.statusText}`);
        }

        const result = await response.json();

        // Ki·ªÉm tra tr·∫°ng th√°i th√†nh c√¥ng trong n·ªôi dung JSON tr·∫£ v·ªÅ
        if (!result.success) {
          throw new Error(result.message || 'Server b√°o c√°o c·∫≠p nh·∫≠t kh√¥ng th√†nh c√¥ng.');
        }

        // === PH·∫¶N S·ª¨A L·ªñI CH√çNH N·∫∞M ·ªû ƒê√ÇY ===
        // 1. T·∫°o th√¥ng b√°o th√†nh c√¥ng d·ª±a tr√™n s·ªë l∆∞·ª£ng b·∫£n ghi ƒë√£ g·ª≠i ƒëi.
        showTempMessage(`C·∫≠p nh·∫≠t th√†nh c√¥ng ${payload.length} ƒë∆°n h√†ng. ƒêang t·∫£i l·∫°i d·ªØ li·ªáu...`);

        // 2. X√≥a c√°c thay ƒë·ªïi ƒëang ch·ªù trong localStorage v√¨ ch√∫ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng.
        clearPendingChanges();

        // 3. ·∫®n popover ƒëi.
        hideStatusPopover();

        // 4. T·∫£i l·∫°i to√†n b·ªô d·ªØ li·ªáu ƒë·ªÉ ƒë·∫£m b·∫£o giao di·ªán ƒë·ªìng b·ªô 100% v·ªõi server.
        setTimeout(loadData, 1000);

      } catch (error) {
        console.error("L·ªói khi c·∫≠p nh·∫≠t t·ª´ popover:", error);
        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói, kh√¥ng x√≥a thay ƒë·ªïi ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ th·ª≠ l·∫°i.
        showTempMessage(`L·ªói c·∫≠p nh·∫≠t: ${error.message}. C√°c thay ƒë·ªïi v·∫´n ƒë∆∞·ª£c l∆∞u.`, true);
      } finally {
        // Lu√¥n k√≠ch ho·∫°t l·∫°i n√∫t b·∫•m d√π th√†nh c√¥ng hay th·∫•t b·∫°i.
        updateBtn.disabled = false;
        updateBtn.textContent = originalText;
      }
    }

    function handleCancelAllChanges() {
      if (Object.keys(getPendingChanges()).length === 0) {
        showTempMessage('Kh√¥ng c√≥ thay ƒë·ªïi n√†o ƒë·ªÉ h·ªßy.', true);
        return;
      }
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën h·ªßy t·∫•t c·∫£ c√°c thay ƒë·ªïi ch∆∞a ƒë∆∞·ª£c l∆∞u? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
        clearPendingChanges();
        showTempMessage('ƒê√£ h·ªßy t·∫•t c·∫£ c√°c thay ƒë·ªïi ƒëang ch·ªù. ƒêang t·∫£i l·∫°i d·ªØ li·ªáu...');

        // 2. ·∫®n popover
        hideStatusPopover();

        // 3. T·∫£i l·∫°i to√†n b·ªô d·ªØ li·ªáu t·ª´ server ƒë·ªÉ kh√¥i ph·ª•c tr·∫°ng th√°i g·ªëc
        // ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng nh·∫•t ƒë·ªÉ s·ª≠a l·ªói
        setTimeout(loadData, 500); // Th√™m m·ªôt kho·∫£ng tr·ªÖ nh·ªè ƒë·ªÉ ng∆∞·ªùi d√πng ƒë·ªçc th√¥ng b√°o
      }
    }

    // --- Local Storage Change Management ---
    function getPendingChanges() {
      return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    }

    function savePendingChange(primaryKey, field, value) {
      const changes = getPendingChanges();
      if (!changes[primaryKey]) {
        changes[primaryKey] = { "M√£ ƒë∆°n h√†ng": primaryKey };
      }
      changes[primaryKey][field] = value;
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(changes));
      // console.log('Change saved to local storage:', { primaryKey, field, value });
      updateStatusButtonUI();
    }

    function removePendingChange(primaryKey) {
      const changes = getPendingChanges();
      delete changes[primaryKey];
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(changes));
      updateStatusButtonUI();
    }

    function clearPendingChanges() {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      // console.log('Local storage cleared.');
      updateStatusButtonUI();
    }


    const mainTabConfig = { data: () => staffFilteredData, controls: { refreshBtn: 'refreshData', updateBtn: 'updateAll', clearBtn: 'clearFilters', startDate: 'startDateFilter', endDate: 'endDateFilter', product: 'productFilter', market: 'marketFilter', summary: 'summaryInfo' }, table: { head: 'tableHead', body: 'tableBody' }, dynamicOptions: () => dynamicFilterOptions };
    const japanTabConfig = { data: () => japanData, controls: { refreshBtn: 'japanRefreshData', updateBtn: 'japanUpdateAll', clearBtn: 'japanClearFilters', startDate: 'japanStartDateFilter', endDate: 'japanEndDateFilter', product: 'japanProductFilter', staff: 'japanStaffFilter', summary: 'japanSummaryInfo' }, table: { head: 'japanTableHead', body: 'japanTableBody' }, dynamicOptions: () => japanDynamicFilterOptions };
    const leaderTabConfig = { data: () => leaderData, controls: { refreshBtn: 'leaderRefreshData', updateBtn: 'leaderUpdateAll', clearBtn: 'leaderClearFilters', startDate: 'leaderStartDateFilter', endDate: 'leaderEndDateFilter', product: 'leaderProductFilter', summary: 'leaderSummaryInfo' }, table: { head: 'leaderTableHead', body: 'leaderTableBody' }, dynamicOptions: () => leaderDynamicFilterOptions };
    const mentionedTabConfig = { data: () => mentionedData, controls: { refreshBtn: 'mentionedRefreshData', updateBtn: 'mentionedUpdateAll', clearBtn: 'mentionedClearFilters', startDate: 'mentionedStartDateFilter', endDate: 'mentionedEndDateFilter', product: 'mentionedProductFilter', summary: 'mentionedSummaryInfo' }, table: { head: 'mentionedTableHead', body: 'mentionedTableBody' }, dynamicOptions: () => mentionedDynamicFilterOptions };
    const hcmTabConfig = { data: () => hcmData, controls: { refreshBtn: 'hcmRefreshData', updateBtn: 'hcmUpdateAll', clearBtn: 'hcmClearFilters', startDate: 'hcmStartDateFilter', endDate: 'hcmEndDateFilter', product: 'hcmProductFilter', staff: 'hcmStaffFilter', summary: 'hcmSummaryInfo' }, table: { head: 'hcmTableHead', body: 'hcmTableBody' }, dynamicOptions: () => hcmDynamicFilterOptions };
    const hanoiTabConfig = { data: () => hanoiData, controls: { refreshBtn: 'hanoiRefreshData', updateBtn: 'hanoiUpdateAll', clearBtn: 'hanoiClearFilters', startDate: 'hanoiStartDateFilter', endDate: 'hanoiEndDateFilter', market: 'hanoiMarketFilter', product: 'hanoiProductFilter', staff: 'hanoiStaffFilter', summary: 'hanoiSummaryInfo' }, table: { head: 'hanoiTableHead', body: 'hanoiTableBody' }, dynamicOptions: () => hanoiDynamicFilterOptions };

    const allTabConfigs = [mainTabConfig, japanTabConfig, leaderTabConfig, mentionedTabConfig, hcmTabConfig, hanoiTabConfig];

    function getDateTimeVN(dateInput) {
      let date;
      if (!dateInput) {
        date = new Date();
      } else {
        date = new Date(dateInput);
        if (isNaN(date.getTime())) {
          console.warn("‚ö†Ô∏è Invalid dateInput:", dateInput);
          return "Ng√†y kh√¥ng h·ª£p l·ªá";
        }
      }
      const options = { timeZone: "Asia/Ho_Chi_Minh", hour12: false };
      const vnDate = new Date(date.toLocaleString("en-US", options));
      const dd = String(vnDate.getDate()).padStart(2, "0");
      const mm = String(vnDate.getMonth() + 1).padStart(2, "0");
      const yyyy = vnDate.getFullYear();
      const HH = String(vnDate.getHours()).padStart(2, "0");
      const MM = String(vnDate.getMinutes()).padStart(2, "0");
      const SS = String(vnDate.getSeconds()).padStart(2, "0");
      return `${dd}/${mm}/${yyyy} ${HH}:${MM}:${SS}`;
    }

    function getFixedColumnCount() { const e = document.getElementById("fixedColumnCountInput"), t = parseInt(e.value, 10); return isNaN(t) || t < 0 ? 0 : t }
    function handleFixedColumnCountChange() { const newCount = getFixedColumnCount(); const activeTab = document.querySelector(".content-tab.active"); if (!activeTab) return; const activeConfig = allTabConfigs.find(c => c.table.body === activeTab.querySelector("tbody")?.id); if (!activeConfig) return; const tableHead = document.getElementById(activeConfig.table.head); const tableBody = document.getElementById(activeConfig.table.body); if (!tableHead || !tableBody) return; const allRows = [...tableHead.querySelectorAll("tr"), ...tableBody.querySelectorAll("tr")]; allRows.forEach(row => { for (let i = 0; i < row.cells.length; i++) { const cell = row.cells[i]; if (i < newCount) { cell.classList.add("fixed-column") } else { cell.classList.remove("fixed-column"); cell.style.left = "" } } }); updateStickyColumns(activeConfig) }
    function updateStickyColumns(config) { const fixedCount = getFixedColumnCount(); const tableHead = document.getElementById(config.table.head); const tableBody = document.getElementById(config.table.body);[...tableHead.querySelectorAll(".fixed-column"), ...tableBody.querySelectorAll(".fixed-column")].forEach(c => c.style.left = ""); if (fixedCount <= 0) return; const headerRow = tableHead.querySelector("tr"); if (!headerRow) return; let leftOffset = 0; for (let i = 0; i < fixedCount; i++) { const th = headerRow.cells[i]; if (!th) continue; th.style.left = leftOffset + "px"; const rows = tableBody.querySelectorAll("tr"); rows.forEach(row => { if (row.cells[i]) { row.cells[i].style.left = leftOffset + "px" } }); leftOffset += th.offsetWidth } }
    function getUrlParameter(name) { name = name.replace(/[\[\]]/g, "\\$&"); const regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(window.location.href); if (!results) return null; if (!results[2]) return ""; return decodeURIComponent(results[2].replace(/\+/g, " ")) }
    function parseDateString(dateString) { if (!dateString || typeof dateString !== "string") return null; const cleanedDateString = dateString.trim().replace(/[^\d\/\-\s]/g, ""); if (/^\d{4}-\d{2}-\d{2}/.test(cleanedDateString)) { const d = new Date(cleanedDateString); if (!isNaN(d.getTime())) return d } const parts = cleanedDateString.match(/^(\d{1,2})[/\-](\d{1,2})[/\-](\d{4})/); if (parts) { const month = parseInt(parts[1], 10), day = parseInt(parts[2], 10), year = parseInt(parts[3], 10); if (year > 1e3 && month > 0 && month <= 12 && day > 0 && day <= 31) { const d = new Date(Date.UTC(year, month - 1, day)); if (d.getUTCFullYear() === year && d.getUTCMonth() === month - 1) return d } } return null }
    function formatDate(dateString) { const originalValue = typeof dateString === "string" ? dateString.trim() : ""; if (!originalValue) return { display: "", original: "" }; const dateObj = parseDateString(originalValue); if (dateObj) { const day = String(dateObj.getUTCDate()).padStart(2, "0"), month = String(dateObj.getUTCMonth() + 1).padStart(2, "0"), year = dateObj.getUTCFullYear(); return { display: `${day}/${month}/${year}`, original: originalValue } } return { display: originalValue, original: originalValue } }

    // --- OPTIMIZED STAFF FETCHING ---
    async function fetchAllStaffData() {
      if (allStaffData.length > 0) return allStaffData;
      try {
        const staffApiUrl = `https://n-api-rouge.vercel.app/sheet/getSheets?rangeSheet=A:K&sheetName=Nh%C3%A2n%20s%E1%BB%B1&spreadsheetId=1Cl-56By1eYFB4G7ITuG0IQhH39ITwo0AkZPFvsLfo54`;
        const response = await fetch(staffApiUrl, { cache: "no-store" });
        if (!response.ok) throw new Error("L·ªói m·∫°ng khi t·∫£i data nh√¢n vi√™n");
        const results = await response.json();
        allStaffData = results?.rows?.map(item => ({
          idnv: item['id'], ho_va_ten: item['H·ªç V√† T√™n'], bo_phan: item['B·ªô ph·∫≠n'], vi_tri: item['V·ªã tr√≠'], email: item['email'], sdt: item['SƒêT'], team: item['Team'], chi_nhanh: item['chi nh√°nh'], ca: item['Ca'], vi_tri_van_don: item['V·ªã tr√≠ v·∫≠n ƒë∆°n'], link_van_don: item['link v·∫≠n ƒë∆°n']
        })) || [];
        return allStaffData;
      } catch (error) {
        showError(error.message);
        throw error;
      }
    }

    async function fetchStaffInfo(idns) {
      const data = await fetchAllStaffData();
      let staffMember = data.find(staff => String(staff.idnv) === idns);
      if (!staffMember) throw new Error(`Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n v·ªõi ID: ${idns}`);

      const memberNames = new Set();
      if (staffMember) {
        if (staffMember.ho_va_ten) memberNames.add(staffMember.ho_va_ten);
        if (staffMember.vi_tri === "Leader" && staffMember.team) {
          const teamName = staffMember.team;
          data.forEach(member => {
            if (member.team === teamName && member.ho_va_ten) memberNames.add(member.ho_va_ten);
          });
        }
      }
      teamMembers = Array.from(memberNames);
      return staffMember;
    }

    async function fetchMultipleStaffInfo(idArray) {
      if (!idArray || idArray.length === 0) return [];
      const data = await fetchAllStaffData();
      const staffNames = new Set();
      idArray.forEach(id => {
        const staffMember = data.find(staff => String(staff.idnv) === id.trim());
        if (staffMember && staffMember.ho_va_ten) {
          staffNames.add(staffMember.ho_va_ten);
        }
      });
      if (staffNames.size === 0) {
        console.warn("Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n n√†o h·ª£p l·ªá cho c√°c ID trong id1:", idArray);
      }
      return Array.from(staffNames);
    }

    function showError(message, containerId = "tableBody") { const container = document.getElementById(containerId), colCount = displayColumns.length; container.innerHTML = `<tr><td colspan="${colCount}" class="no-data" style="text-align: center;">${message}</td></tr>` }
    function updateSummaryInfo(config) { 
        const tableBody = document.getElementById(config.table.body); 
        const summaryElement = document.getElementById(config.controls.summary); 
        const originalData = config.data(); 
        
        let visibleCount = 0; 
        let totalAmount = 0; 
        
        tableBody.querySelectorAll('tr').forEach(tr => { 
            if (tr.style.display !== 'none') { 
                visibleCount++; 
                
                // L·∫•y "M√£ ƒë∆°n h√†ng" tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
                const orderCodeCell = tr.cells[0]; // C·ªôt "M√£ ƒë∆°n h√†ng" lu√¥n l√† c·ªôt ƒë·∫ßu ti√™n
                const orderCode = orderCodeCell ? getDOMCellValue(orderCodeCell) : null;
                
                if (orderCode) {
                    // T√¨m d·ªØ li·ªáu trong originalData d·ª±a tr√™n "M√£ ƒë∆°n h√†ng"
                    const rowData = originalData.find(item => item["M√£ ƒë∆°n h√†ng"] === orderCode);
                    
                    if (rowData) {
                        // Th·ª≠ nhi·ªÅu t√™n c·ªôt c√≥ th·ªÉ c√≥
                        let amountValue = rowData["T·ªïng ti·ªÅn VNƒê"] || 
                                        rowData["T·ªïng_ti·ªÅn_VNƒê"] || 
                                        rowData["T·ªïng ti·ªÅn VND"] ||
                                        rowData["T·ªïng_ti·ªÅn_VND"] ||
                                        rowData["Gi√° b√°n"] ||
                                        rowData["Gi√°_b√°n"] ||
                                        0;
                        
                        // Chuy·ªÉn ƒë·ªïi th√†nh s·ªë
                        const numericValue = parseFloat(String(amountValue).replace(/[^\d.-]/g, "")) || 0; 
                        totalAmount += numericValue;
                    }
                }
            } 
        }); 
        
        const formattedAmount = new Intl.NumberFormat("vi-VN", { style: "currency", currency: "VND" }).format(totalAmount); 
        summaryElement.innerHTML = `T·ªïng ƒë∆°n: <b>${visibleCount}</b> | T·ªïng ti·ªÅn: <b style="color:var(--success-color)">${formattedAmount}</b>`; 
    }
    function getDOMCellValue(e) { if (!e) return ""; const t = e.querySelector("select"); if (t) return t.value; const n = e.querySelector("input"); return n ? n.value : e.textContent.trim() }
    
    // üîß Helper function to get "M√£ ƒë∆°n h√†ng" from selected cell
    function getOrderCodeFromCell(cell) {
      try {
        const tr = cell.closest('tr');
        if (!tr) return 'N/A';
        
        // üî• FIX: L·∫•y "M√£ ƒë∆°n h√†ng" tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
        // C·ªôt "M√£ ƒë∆°n h√†ng" lu√¥n l√† c·ªôt ƒë·∫ßu ti√™n (index 0)
        const orderCodeCell = tr.cells[0]; // displayColumns[0] = "M√£ ƒë∆°n h√†ng"
        if (!orderCodeCell) return 'N/A';
        
        // L·∫•y gi√° tr·ªã tr·ª±c ti·∫øp t·ª´ DOM cell
        const orderCode = getDOMCellValue(orderCodeCell);
        return orderCode || 'N/A';
      } catch (error) {
        console.warn('Error getting order code:', error);
        return 'ERROR';
      }
    }
    function updateSelectionSummary() { const summaryEl = document.getElementById("selectionSummary"); if (!summaryEl || !document.getElementById("contentData").classList.contains("active")) { if (summaryEl) summaryEl.innerHTML = ""; return } if (selectedCells.size <= 1) { summaryEl.innerHTML = ""; return } let totalSum = 0, numericCount = 0, nonBlankCount = 0; selectedCells.forEach(cell => { const value = getDOMCellValue(cell); if (value !== "") nonBlankCount++; const numericValue = parseFloat(String(value).replace(/[^0-9.-]/g, "")); if (!isNaN(numericValue)) { totalSum += numericValue; numericCount++ } }); let summaryParts = [`Count: <b>${nonBlankCount}</b>`]; if (numericCount > 0) summaryParts.push(`Sum: <b>${totalSum.toLocaleString("vi-VN")}</b>`); summaryEl.innerHTML = summaryParts.join(" | ") }
    function setupCellSelection(tableBodyId) { const tableBody = document.getElementById(tableBodyId); if (!tableBody) return; let lastClickTime = 0, lastClickCell = null; tableBody.addEventListener("mousedown", e => { const td = e.target.closest("td"); if (!td) return; if (e.target.tagName === "SELECT" || e.target.tagName === "INPUT") return; if (!e.ctrlKey && !e.metaKey && !e.shiftKey) { isMouseDown = !0; startCell = td; selectedCells.forEach(cell => cell.classList.remove("cell-selected")); selectedCells.clear(); td.classList.add("cell-selected"); selectedCells.add(td); e.preventDefault() } }); tableBody.addEventListener("click", e => { const td = e.target.closest("td"); if (!td) return; if (e.target.tagName === "SELECT" || e.target.tagName === "INPUT") return; const currentTime = (new Date).getTime(), isDoubleClick = currentTime - lastClickTime < 300 && lastClickCell === td; if (isDoubleClick) handleEditCell(td, tableBodyId); else { if (e.shiftKey && startCell) selectCellsBetween(startCell, td); else if (e.ctrlKey || e.metaKey) { td.classList.toggle("cell-selected"); if (td.classList.contains("cell-selected")) selectedCells.add(td); else selectedCells.delete(td) } else { selectedCells.forEach(cell => cell.classList.remove("cell-selected")); selectedCells.clear(); td.classList.add("cell-selected"); selectedCells.add(td) } startCell = td } lastClickTime = currentTime; lastClickCell = td; updateSelectionSummary() }); tableBody.addEventListener("mouseover", e => { if (isMouseDown) { const td = e.target.closest("td"); if (td) selectCellsBetween(startCell, td) } }); document.addEventListener("mouseup", () => { if (isMouseDown) { isMouseDown = !1; updateSelectionSummary() } }) }
    function selectCellsBetween(start, end) {
      if (!start || !end || start.closest("tbody") !== end.closest("tbody")) return;

      const tableBody = start.closest("tbody");
      const allRows = Array.from(tableBody.rows);
      if (allRows.length === 0) return;

      const startRowIndex = allRows.findIndex(row => row.contains(start));
      const endRowIndex = allRows.findIndex(row => row.contains(end));
      const startColIndex = start.cellIndex;
      const endColIndex = end.cellIndex;

      const minRow = Math.min(startRowIndex, endRowIndex);
      const maxRow = Math.max(startRowIndex, endRowIndex);
      const minCol = Math.min(startColIndex, endColIndex);
      const maxCol = Math.max(startColIndex, endColIndex);

      // X√≥a l·ª±a ch·ªçn c≈© v√† x√¢y d·ª±ng l·∫°i t·ª´ ƒë·∫ßu ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh ƒë√∫ng ƒë·∫Øn
      selectedCells.forEach(cell => cell.classList.remove("cell-selected"));
      selectedCells.clear();

      for (let i = minRow; i <= maxRow; i++) {
        for (let j = minCol; j <= maxCol; j++) {
          const cell = allRows[i]?.cells[j];
          if (cell) {
            cell.classList.add("cell-selected");
            selectedCells.add(cell);
          }
        }
      }
      
      // üîç LOG: Khi ch·ªçn cells (c√≥ th·ªÉ b·∫≠t/t·∫Øt khi c·∫ßn debug)
      console.log('üîµ Cell selection updated');
      console.log('Selected cells count:', selectedCells.size);
      console.log('Selected cells:', Array.from(selectedCells));
      // console.log('T·ªïng s·ªë √¥ ƒë∆∞·ª£c ch·ªçn:', selectedCells.size);
      // console.log('Chi ti·∫øt selection:', Array.from(selectedCells).map(cell => ({
      //   orderCode: getOrderCodeFromCell(cell),
      //   text: cell.textContent.trim(),
      //   rowDisplay: cell.parentNode.style.display,
      //   isHidden: cell.parentNode.style.display === 'none',
      //   rowIndex: cell.parentNode.rowIndex,
      //   colIndex: cell.cellIndex,
      //   colName: displayColumns[cell.cellIndex]
      // })));
    }
    async function processCellUpdate(primaryKey, updates) {
      const payload = { "M√£ ƒë∆°n h√†ng": primaryKey, ...updates };
      try {
        const response = await fetch(UPDATE_SINGLE_URL, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (!response.ok || !result.success) {
          throw new Error(result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
        }
        showTempMessage(`ƒê√£ c·∫≠p nh·∫≠t ƒë∆°n ${primaryKey}`);
        removePendingChange(primaryKey); // X√≥a kh·ªèi local storage n·∫øu th√†nh c√¥ng
      } catch (error) {
        console.error("L·ªói khi c·∫≠p nh·∫≠t t·ª©c th√¨:", error);
        showTempMessage(`L·ªói c·∫≠p nh·∫≠t ƒë∆°n ${primaryKey}. ƒê√£ l∆∞u thay ƒë·ªïi t·∫°m th·ªùi.`, true);
        Object.entries(updates).forEach(([field, value]) => {
          savePendingChange(primaryKey, field, value); // L∆∞u v√†o local storage n·∫øu th·∫•t b·∫°i
        });
      }
    }

    function handleEditCell(td, tableBodyId) {
      if (!td.classList.contains("editable") || td.classList.contains("editing") || td.querySelector("select")) return;
      const dateInput = td.querySelector("input.date-input");
      if (dateInput) {
        dateInput.focus();
        return
      }
      const originalValue = td.textContent,
        input = document.createElement("input");
      input.type = "text";
      input.value = originalValue;
      td.textContent = "";
      td.appendChild(input);
      td.classList.add("editing");
      input.focus();
      
      const finishEdit = save => {
        const newValue = save ? input.value.trim() : originalValue;
        td.textContent = newValue;
        td.classList.remove("editing");
        if (save && newValue !== originalValue) {
          td.classList.add("highlight");
          const tr = td.closest("tr");
          const colName = displayColumns[td.cellIndex];
          
          // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
          const primaryKey = getOrderCodeFromCell(td);
          
          if (primaryKey && primaryKey !== 'N/A') {
            const config = allTabConfigs.find(c => c.table.body === tableBodyId);
            if (config) {
              
              // C·∫≠p nh·∫≠t allData
              if (allData && allData.length > 0) {
                const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
                if (allDataIndex !== -1) {
                  allData[allDataIndex][colName] = newValue;
                  
                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    // console.log(`üõ†Ô∏è C·∫≠p nh·∫≠t "Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2" cho ƒë∆°n ${primaryKey} th√†nh ${timestamp}`);
                    
                    allData[allDataIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                    
                    // C·∫≠p nh·∫≠t giao di·ªán
                    const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                    if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                      tr.cells[dateColIndex].textContent = timestamp;
                      tr.cells[dateColIndex].classList.add('highlight');
                    }
                  }
                } else {
                  console.error('‚ùå Kh√¥ng t√¨m th·∫•y order code trong allData:', primaryKey);
                }
              }
            }
            
            const updates = { [colName]: newValue };
            if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
              const timestamp = getDateTimeVN();
              updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
            }
            
            processCellUpdate(primaryKey, updates);
          } else {
            console.error('‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c primary key t·ª´ DOM!');
          }
        }
        input.removeEventListener("blur", onBlur);
        input.removeEventListener("keydown", onKeyDown);
      };
      
      const onBlur = () => finishEdit(true);
      const onKeyDown = e => {
        if (e.key === "Enter") {
          e.preventDefault();
          finishEdit(true);
        } else if (e.key === "Escape") {
          e.preventDefault();
          finishEdit(false);
        }
      };
      input.addEventListener("blur", onBlur);
      input.addEventListener("keydown", onKeyDown);
    }
    function copySelectedCells() {
      // 1. L·ªçc ra ch·ªâ nh·ªØng √¥ ƒëang ƒë∆∞·ª£c hi·ªÉn th·ªã (c√≥ h√†ng cha kh√¥ng b·ªã ·∫©n)
      const visibleSelectedCells = Array.from(selectedCells).filter(
        cell => cell.parentNode.style.display !== 'none'
      );

      if (visibleSelectedCells.length === 0) {
        showTempMessage('Kh√¥ng c√≥ √¥ n√†o hi·ªÉn th·ªã ƒë·ªÉ sao ch√©p.');
        return;
      }

      // 2. Nh√≥m c√°c √¥ theo h√†ng (d√πng Map ƒë·ªÉ duy tr√¨ th·ª© t·ª±)
      const rows = new Map();
      visibleSelectedCells.forEach(cell => {
        const rowIndex = cell.parentNode.rowIndex; // L·∫•y ch·ªâ s·ªë h√†ng ƒë·ªÉ s·∫Øp x·∫øp
        if (!rows.has(rowIndex)) {
          rows.set(rowIndex, []);
        }
        rows.get(rowIndex).push(cell);
      });

      // 3. S·∫Øp x·∫øp c√°c h√†ng v√† t·∫°o chu·ªói TSV (Tab-Separated Values)
      const sortedRowKeys = Array.from(rows.keys()).sort((a, b) => a - b);

      const tsv = sortedRowKeys.map(rowIndex => {
        const cellsInRow = rows.get(rowIndex);
        // S·∫Øp x·∫øp c√°c √¥ trong c√πng m·ªôt h√†ng theo ƒë√∫ng th·ª© t·ª± c·ªôt
        return cellsInRow
          .sort((a, b) => a.cellIndex - b.cellIndex)
          .map(cell => getDOMCellValue(cell)) // L·∫•y gi√° tr·ªã t·ª´ √¥
          .join('\t'); // Ph√¢n t√°ch c√°c √¥ b·∫±ng k√Ω t·ª± tab
      }).join('\n'); // Ph√¢n t√°ch c√°c h√†ng b·∫±ng k√Ω t·ª± xu·ªëng d√≤ng

      // 4. Ghi v√†o b·ªô nh·ªõ t·∫°m
      navigator.clipboard.writeText(tsv).then(
        () => showTempMessage(`ƒê√£ sao ch√©p ${visibleSelectedCells.length} √¥ ƒëang hi·ªÉn th·ªã.`),
        err => console.error("L·ªói sao ch√©p:", err)
      );
    }
    async function pasteToSelectedCells(text) {
      if (selectedCells.size === 0) return;

      // console.log(`üöÄ === B·∫ÆT ƒê·∫¶U PASTE ===`);
      // console.log(`üìã D·ªØ li·ªáu paste:`, text);
      
      // // üîç LOG: Chi ti·∫øt t·∫•t c·∫£ √¥ ƒë√£ ƒë∆∞·ª£c SELECTED
      // console.log(`üìç SELECTED CELLS (${selectedCells.size} √¥):`);
      // Array.from(selectedCells).forEach((cell, index) => {
      //   const orderCode = getOrderCodeFromCell(cell);
      //   const colName = displayColumns[cell.cellIndex];
      //   const currentValue = getDOMCellValue(cell);
      //   const isVisible = cell.parentNode.style.display !== 'none';
      //   console.log(`  [${index}] ${orderCode} | C·ªôt: ${colName} | Gi√° tr·ªã: "${currentValue}" | Hi·ªÉn th·ªã: ${isVisible}`);
      // });

      // üîç LOG: T·∫•t c·∫£ √¥ ƒë∆∞·ª£c ch·ªçn (k·ªÉ c·∫£ b·ªã ·∫©n)
      // console.log('=== PASTE DEBUG ===');
      // console.log('T·ªïng s·ªë √¥ ƒë√£ ch·ªçn:', selectedCells.size);
      // console.log('Chi ti·∫øt c√°c √¥ ƒë√£ ch·ªçn:', Array.from(selectedCells).map(cell => ({
      //   orderCode: getOrderCodeFromCell(cell),
      //   text: cell.textContent.trim(),
      //   rowDisplay: cell.parentNode.style.display,
      //   rowIndex: cell.parentNode.rowIndex,
      //   colIndex: cell.cellIndex,
      //   colName: displayColumns[cell.cellIndex],
      //   isHidden: cell.parentNode.style.display === 'none'
      // })));

      const dataGrid = text.split("\n").map(row => row.split("\t"));
      
      // üî• FIX: L·ªçc ch·ªâ nh·ªØng √¥ t·ª´ h√†ng hi·ªÉn th·ªã
      const visibleSelectedCells = Array.from(selectedCells).filter(
        cell => cell.parentNode.style.display !== 'none'
      );
      
      // üîç LOG: √î sau khi l·ªçc
      // console.log('S·ªë √¥ hi·ªÉn th·ªã sau l·ªçc:', visibleSelectedCells.length);
      // console.log('Chi ti·∫øt c√°c √¥ hi·ªÉn th·ªã:', visibleSelectedCells.map(cell => ({
      //   orderCode: getOrderCodeFromCell(cell),
      //   text: cell.textContent.trim(),
      //   rowIndex: cell.parentNode.rowIndex,
      //   colIndex: cell.cellIndex,
      //   colName: displayColumns[cell.cellIndex]
      // })));
      
      if (visibleSelectedCells.length === 0) {
        showTempMessage('Kh√¥ng c√≥ √¥ n√†o hi·ªÉn th·ªã ƒë·ªÉ paste.');
        return;
      }
      
      const sortedCells = visibleSelectedCells.sort((a, b) => a.parentNode.rowIndex - b.parentNode.rowIndex || a.cellIndex - b.cellIndex);
      const firstCell = sortedCells[0];
      const table = firstCell.closest("table");

      if (!table) return;

      const startRowIndex = Array.from(table.rows).indexOf(firstCell.closest("tr"));
      const startColIndex = firstCell.cellIndex;
      let pasteCount = 0;
      const batchUpdates = [];

      if (dataGrid.length === 1 && dataGrid[0].length === 1) {
        // TR∆Ø·ªúNG H·ª¢P: COPY 1 √î, PASTE V√ÄO NHI·ªÄU √î
        const value = dataGrid[0][0];
        sortedCells.forEach(cell => {
          if (cell && cell.classList.contains("editable")) {
            const tr = cell.closest("tr");
            const config = allTabConfigs.find(cfg => cfg.table.body === cell.closest("tbody").id);
            if (!tr || !config) return;

            const rowIndex = parseInt(tr.dataset.rowIndex);
            const colName = displayColumns[cell.cellIndex];
            
            // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
            const primaryKey = getOrderCodeFromCell(cell);
            
            if (primaryKey && primaryKey !== 'N/A' && getDOMCellValue(cell) !== value) {
              // console.log(`‚úÖ PASTE TH·ª∞C T·∫æ: ${primaryKey} | C·ªôt: ${colName} | "${getDOMCellValue(cell)}" ‚Üí "${value}" | DOM rowIndex: ${rowIndex}`);
              
              // 1. C·∫≠p nh·∫≠t giao di·ªán
              cell.textContent = value;
              cell.classList.add("highlight");

              // === START: CODE ƒê√É S·ª¨A L·ªñI (Tr∆∞·ªùng h·ª£p 1) ===
              // 2. C·∫≠p nh·∫≠t m·∫£ng d·ªØ li·ªáu JavaScript (n·∫øu c√≥ rowIndex h·ª£p l·ªá)
              const dataArray = config.data();
              // console.log('dataArray:', dataArray);
              
              if (dataArray && !isNaN(rowIndex) && dataArray[rowIndex] && primaryKey === dataArray[rowIndex]["M√£ ƒë∆°n h√†ng"]) {
                // console.log(`üîÑ C·∫≠p nh·∫≠t dataArray[${rowIndex}]: "${dataArray[rowIndex]["M√£ ƒë∆°n h√†ng"]}" - tr∆∞·ªõc: "${dataArray[rowIndex][colName]}" ‚Üí sau: "${value}"`);
                dataArray[rowIndex][colName] = value;
                if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                  const timestamp = getDateTimeVN();
                  dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                  // C·∫≠p nh·∫≠t giao di·ªán cho c·ªôt ng√†y th√°ng
                  const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                  if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                    tr.cells[dateColIndex].textContent = timestamp;
                    tr.cells[dateColIndex].classList.add('highlight');
                  }
                }
              }
              
              // üî• FIX: C·∫≠p nh·∫≠t allData ƒë·ªÉ ƒë·ªìng b·ªô khi paste "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"
              if (allData && allData.length > 0) {
                const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
                if (allDataIndex !== -1) {
                  allData[allDataIndex][colName] = value;
                  
                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    allData[allDataIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                    // console.log(`üîÑ Updated allData for paste: ${primaryKey} - ${colName} = "${value}", timestamp = ${timestamp}`);
                  }
                }
              }
              // === END: CODE ƒê√É S·ª¨A L·ªñI ===

              // 3. Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update (API)
              const updates = {
                [colName]: value
              };
              if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = getDateTimeVN();
              }
              batchUpdates.push({
                "M√£ ƒë∆°n h√†ng": primaryKey,
                ...updates
              });
              pasteCount++;
            }
          }
        });
      } else {
        // TR∆Ø·ªúNG H·ª¢P: COPY NHI·ªÄU √î, PASTE V√ÄO B·∫¢NG
        dataGrid.forEach((row, r) => {
          row.forEach((value, c) => {
            const targetRow = table.rows[startRowIndex + r];
            if (targetRow && targetRow.style.display !== 'none') {
              const targetCell = targetRow.cells[startColIndex + c];
              if (targetCell && targetCell.classList.contains("editable")) {
                const tr = targetCell.closest("tr");
                const config = allTabConfigs.find(cfg => cfg.table.body === targetCell.closest("tbody").id);
                if (!config) return;

                const rowIndex = parseInt(tr.dataset.rowIndex);
                const colName = displayColumns[targetCell.cellIndex];
                
                // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
                const primaryKey = getOrderCodeFromCell(targetCell);

                if (primaryKey && primaryKey !== 'N/A' && getDOMCellValue(targetCell) !== value) {
                  // console.log(`‚úÖ PASTE GRID: ${primaryKey} | C·ªôt: ${colName} | "${getDOMCellValue(targetCell)}" ‚Üí "${value}" | DOM rowIndex: ${rowIndex} | Grid[${r}][${c}]`);
                  
                  // 1. C·∫≠p nh·∫≠t giao di·ªán
                  targetCell.textContent = value;
                  targetCell.classList.add("highlight");

                  // === START: CODE ƒê√É S·ª¨A L·ªñI (Tr∆∞·ªùng h·ª£p 2) ===
                  // 2. C·∫≠p nh·∫≠t m·∫£ng d·ªØ li·ªáu JavaScript (n·∫øu c√≥ rowIndex h·ª£p l·ªá)
                  const dataArray = config.data();
                  if (dataArray && !isNaN(rowIndex) && dataArray[rowIndex]) {
                    dataArray[rowIndex][colName] = value;
                    if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                      const timestamp = getDateTimeVN();
                      dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                      // C·∫≠p nh·∫≠t giao di·ªán cho c·ªôt ng√†y th√°ng
                      const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                      if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                        tr.cells[dateColIndex].textContent = timestamp;
                        tr.cells[dateColIndex].classList.add('highlight');
                      }
                    }
                  }
                  // === END: CODE ƒê√É S·ª¨A L·ªñI ===

                  // 3. Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update (API)
                  const updates = {
                    [colName]: value
                  };
                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = getDateTimeVN();
                  }
                  batchUpdates.push({
                    "M√£ ƒë∆°n h√†ng": primaryKey,
                    ...updates
                  });
                  pasteCount++;
                }
              }
            }
          })
        });
      }

      if (batchUpdates.length > 0) {
        // üîç LOG: Payload s·∫Ω g·ª≠i ƒëi
        // console.log('=== PAYLOAD WILL BE SENT ===');
        // console.log('S·ªë b·∫£n ghi s·∫Ω g·ª≠i:', batchUpdates.length);
        // console.log('Chi ti·∫øt payload:', batchUpdates);
        // console.log('==========================================');
        
        try {
          const response = await fetch(UPDATE_BULK_URL, {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(batchUpdates)
          });
          const result = await response.json();

          if (!response.ok || !result.success) {
            throw new Error(result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
          }

          showTempMessage(`ƒê√£ d√°n v√† c·∫≠p nh·∫≠t ${batchUpdates.length} gi√° tr·ªã th√†nh c√¥ng`);

          // üîÑ ƒê·ªìng b·ªô h√≥a v·ªõi allData sau khi API th√†nh c√¥ng
          batchUpdates.forEach(update => {
            const orderCode = update["M√£ ƒë∆°n h√†ng"];
            // console.log(`üíæ ƒê·ªìng b·ªô v·ªõi allData: t√¨m order code "${orderCode}"`);
            if (allData && allData.length > 0) {
              const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === orderCode);
              if (allDataIndex !== -1) {
                Object.entries(update).forEach(([colName, value]) => {
                  if (colName !== "M√£ ƒë∆°n h√†ng") {
                    // console.log(`‚úÖ allData[${allDataIndex}] c·∫≠p nh·∫≠t ${colName}: "${allData[allDataIndex][colName]}" ‚Üí "${value}"`);
                    allData[allDataIndex][colName] = value;
                    
                    // üî• FIX: C·∫≠p nh·∫≠t timestamp v√†o DOM khi paste "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"
                    if (colName === "ƒê∆°n v·ªã v·∫≠n chuy·ªÉn") {
                      // T√¨m row t∆∞∆°ng ·ª©ng trong DOM ƒë·ªÉ c·∫≠p nh·∫≠t c·ªôt timestamp
                      const activeTableBody = document.querySelector('.content-tab.active tbody');
                      if (activeTableBody) {
                        const rows = Array.from(activeTableBody.querySelectorAll('tr'));
                        const targetRow = rows.find(row => {
                          const orderCodeCell = row.cells[0];
                          return orderCodeCell && getDOMCellValue(orderCodeCell) === orderCode;
                        });
                        
                        if (targetRow) {
                          const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                          if (dateColIndex > -1 && targetRow.cells[dateColIndex]) {
                            const timestampFromUpdate = update["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"];
                            if (timestampFromUpdate) {
                              targetRow.cells[dateColIndex].textContent = timestampFromUpdate;
                              targetRow.cells[dateColIndex].classList.add('highlight');
                              // console.log(`üïê Updated timestamp in DOM for order ${orderCode}: ${timestampFromUpdate}`);
                            }
                          }
                        }
                      }
                    }
                  }
                });
              } else {
                console.log(`‚ùå Kh√¥ng t√¨m th·∫•y order code "${orderCode}" trong allData`);
              }
            }
            removePendingChange(orderCode);
          });

        } catch (error) {
          console.error("L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t sau khi d√°n:", error);
          showTempMessage(`ƒê√£ d√°n ${pasteCount} gi√° tr·ªã nh∆∞ng c√≥ l·ªói khi l∆∞u. ƒê√£ l∆∞u thay ƒë·ªïi t·∫°m th·ªùi.`, true);

          batchUpdates.forEach(update => {
            const primaryKey = update["M√£ ƒë∆°n h√†ng"];
            Object.entries(update).forEach(([field, value]) => {
              if (field !== "M√£ ƒë∆°n h√†ng") {
                savePendingChange(primaryKey, field, value);
              }
            });
          });
        }
      } else if (pasteCount > 0) {
        showTempMessage(`ƒê√£ d√°n ${pasteCount} gi√° tr·ªã (kh√¥ng c√≥ thay ƒë·ªïi m·ªõi).`);
      }
      updateSelectionSummary();
    }
    function clearSelectedCells() { 
      // console.log('üî• clearSelectedCells() called');
      // console.log('Selected cells count:', selectedCells.size);
      if (selectedCells.size === 0) {
        console.log('‚ùå No cells selected');
        return; 
      }
      
      const batchUpdates = [];
      let clearCount = 0;
      
      selectedCells.forEach((cell, index) => { 
        // console.log(`Processing cell ${index + 1}:`, cell);
        // console.log(`Cell editable:`, cell.classList.contains('editable'));
        
        if (cell && cell.classList.contains("editable")) {
          const currentValue = getDOMCellValue(cell);
          if (currentValue !== "") {  // Ch·ªâ x·ª≠ l√Ω n·∫øu cell c√≥ gi√° tr·ªã
            const primaryKey = getOrderCodeFromCell(cell);
            const colName = displayColumns[cell.cellIndex];
            
            // console.log(`üîë Primary key: ${primaryKey}, Column: ${colName}, Current value: "${currentValue}"`);
            
            if (primaryKey && primaryKey !== 'N/A' && primaryKey !== 'ERROR') {
              // 1. C·∫≠p nh·∫≠t giao di·ªán ngay l·∫≠p t·ª©c
              const select = cell.querySelector("select");
              if (select) {
                // üî• FIX: Set flag ƒë·ªÉ tr√°nh g·ªçi API ƒë∆°n l·∫ª trong s·ª± ki·ªán change
                select.dataset.isBulkClear = "true";
                select.value = "";
                select.dispatchEvent(new Event("change", { bubbles: true }));
              } else {
                cell.textContent = "";
              }
              cell.classList.add("highlight");
              
              // 2. C·∫≠p nh·∫≠t d·ªØ li·ªáu local
              const tr = cell.closest("tr");
              const config = allTabConfigs.find(c => c.table.body === cell.closest("tbody").id);
              const rowIndex = parseInt(tr.dataset.rowIndex);
              
              if (config && !isNaN(rowIndex)) {
                const dataArray = config.data();
                if (dataArray && dataArray[rowIndex]) {
                  dataArray[rowIndex][colName] = "";
                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                  }
                }
              }
              
              // üî• FIX: C·∫≠p nh·∫≠t allData ƒë·ªÉ ƒë·ªìng b·ªô khi b·ªè l·ªçc
              if (allData && allData.length > 0) {
                const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
                if (allDataIndex !== -1) {
                  // console.log(`üîÑ Updating allData[${allDataIndex}] for order ${primaryKey}: ${colName} = ""`);
                  allData[allDataIndex][colName] = "";
                  
                  if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    allData[allDataIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                    
                    // C·∫≠p nh·∫≠t giao di·ªán cho c·ªôt timestamp n·∫øu hi·ªÉn th·ªã
                    const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                    if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                      tr.cells[dateColIndex].textContent = timestamp;
                      tr.cells[dateColIndex].classList.add('highlight');
                    }
                  }
                } else {
                  console.warn(`‚ö†Ô∏è Could not find order ${primaryKey} in allData for clearing`);
                }
              }
              
              // 3. Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update
              const updates = { [colName]: "" };
              if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = getDateTimeVN();
              }
              
              batchUpdates.push({
                "M√£ ƒë∆°n h√†ng": primaryKey,
                ...updates
              });
              
              clearCount++;
              // console.log(`‚úÖ Cell ${index + 1} prepared for clearing`);
            } else {
              console.log(`‚ùå Invalid primary key for cell ${index + 1}`);
            }
          } else {
            // console.log(`‚ÑπÔ∏è Cell ${index + 1} already empty`);
          }
        } else {
          console.log(`‚ùå Cell ${index + 1} is not editable`);
        }
      }); 
      
      // console.log(`Total cells to clear: ${clearCount}`);
      // console.log('Batch updates payload:', batchUpdates);
      
      // 4. G·ªçi API bulk update n·∫øu c√≥ d·ªØ li·ªáu
      if (batchUpdates.length > 0) {
        processBulkClearUpdate(batchUpdates, clearCount);
      } else {
        showTempMessage('Kh√¥ng c√≥ √¥ n√†o c·∫ßn x√≥a');
      }
    }
    
    // H√†m m·ªõi ƒë·ªÉ x·ª≠ l√Ω bulk update cho vi·ªác x√≥a
    async function processBulkClearUpdate(batchUpdates, clearCount) {
      // console.log('üì° Sending bulk clear update to API');
      try {
        const response = await fetch(UPDATE_BULK_URL, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(batchUpdates)
        });
        
        const result = await response.json();
        
        if (!response.ok || !result.success) {
          throw new Error(result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
        }
        
        // console.log('‚úÖ Bulk clear update successful');
        showTempMessage(`ƒê√£ x√≥a v√† c·∫≠p nh·∫≠t ${clearCount} √¥ th√†nh c√¥ng`);
        
        // X√≥a kh·ªèi pending changes n·∫øu th√†nh c√¥ng
        batchUpdates.forEach(update => {
          removePendingChange(update["M√£ ƒë∆°n h√†ng"]);
        });
        
      } catch (error) {
        console.error("‚ùå L·ªói khi x√≥a h√†ng lo·∫°t:", error);
        showTempMessage(`ƒê√£ x√≥a ${clearCount} √¥ nh∆∞ng c√≥ l·ªói khi l∆∞u. ƒê√£ l∆∞u thay ƒë·ªïi t·∫°m th·ªùi.`, true);
        
        // L∆∞u v√†o pending changes n·∫øu th·∫•t b·∫°i
        batchUpdates.forEach(update => {
          const primaryKey = update["M√£ ƒë∆°n h√†ng"];
          Object.entries(update).forEach(([field, value]) => {
            if (field !== "M√£ ƒë∆°n h√†ng") {
              savePendingChange(primaryKey, field, value);
            }
          });
        });
      }
    }

    function updateCellValue(cell, value) {
      // console.log('üîß updateCellValue() called');
      // console.log('Cell:', cell);
      // console.log('Value to set:', value);
      // console.log('Cell classList:', cell?.classList?.toString());
      
      if (!cell || !cell.classList.contains("editable")) {
        console.log('‚ùå Cell is not editable or null');
        return false;
      }
      
      const select = cell.querySelector("select");
      const dateInput = cell.querySelector("input.date-input");
      let changed = false;

      // console.log('Select element found:', !!select);
      // console.log('Date input found:', !!dateInput);

      if (select) {
        // console.log('Current select value:', select.value);
        // console.log('New value:', value);
        // üî• FIX: Cho ph√©p x√≥a dropdown b·∫±ng c√°ch set value = ""
        if (select.value !== value) {
          select.value = value; // value c√≥ th·ªÉ l√† "" ƒë·ªÉ x√≥a
          // console.log('‚úÖ Select value changed to:', select.value);
          select.dispatchEvent(new Event("change", {
            bubbles: true
          })); // K√≠ch ho·∫°t s·ª± ki·ªán change ƒë·ªÉ logic trong renderTableBody ch·∫°y
          changed = true;
        } else {
          // console.log('‚ÑπÔ∏è Select value unchanged');
        }
      } else if (dateInput) {
        // console.log('üìÖ Processing date input');
        // Logic for date input if any
      } else if (cell.textContent !== value) {
        // console.log('üìù Processing text cell');
        // console.log('Current text:', cell.textContent);
        // console.log('New value:', value);
        cell.textContent = value;
        cell.classList.add("highlight");
        // console.log('‚úÖ Text cell updated');
        changed = true;
        const tr = cell.closest("tr");
        const config = allTabConfigs.find(c => c.table.body === cell.closest("tbody").id);
        const rowIndex = parseInt(tr.dataset.rowIndex);
        const colName = displayColumns[cell.cellIndex];

        // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM thay v√¨ d·ª±a v√†o rowIndex
        const primaryKey = getOrderCodeFromCell(cell);
        // console.log('üîë Primary key from DOM:', primaryKey);

        if (primaryKey && primaryKey !== 'N/A' && primaryKey !== 'ERROR') {
          // === START: CODE ƒê√É S·ª¨A L·ªñI ===
          // C·∫≠p nh·∫≠t gi√° tr·ªã m·ªõi (r·ªóng) v√†o m·∫£ng d·ªØ li·ªáu JavaScript
          if (config && !isNaN(rowIndex)) {
            const dataArray = config.data();
            if (dataArray && dataArray[rowIndex]) {
              // console.log('üìä Updating data array at index:', rowIndex);
              dataArray[rowIndex][colName] = value; // value ·ªü ƒë√¢y l√† ""

              if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                const timestamp = getDateTimeVN();
                dataArray[rowIndex]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
              }
            } else {
              console.log('‚ö†Ô∏è DataArray or rowIndex invalid:', { dataArray: !!dataArray, rowIndex });
            }
          } else {
            console.log('‚ö†Ô∏è Config or rowIndex invalid:', { config: !!config, rowIndex });
          }
          // === END: CODE ƒê√É S·ª¨A L·ªñI ===

          // Chu·∫©n b·ªã API update
          const updates = {
            [colName]: value
          };
          if (colName === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
            const timestamp = getDateTimeVN();
            updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
            const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
            if (dateColIndex > -1 && tr.cells[dateColIndex]) {
              tr.cells[dateColIndex].textContent = timestamp;
              tr.cells[dateColIndex].classList.add('highlight');
            }
          }
          
          // console.log('üì° Sending API update:', { primaryKey, updates });
          processCellUpdate(primaryKey, updates);
        } else {
          console.log('‚ùå Invalid primary key, skipping API update');
        }
        changed = true;
      } else {
        console.log('‚ÑπÔ∏è No change needed for this cell type');
      }
      
      // console.log('üîß updateCellValue result:', changed);
      return changed;
    }

    function showTempMessage(e, t = !1) { document.querySelector(".temp-message")?.remove(); const n = document.createElement("div"); n.textContent = e, Object.assign(n.style, { position: "fixed", bottom: "20px", right: "20px", backgroundColor: t ? "rgba(220, 53, 69, 0.9)" : "rgba(40, 167, 69, 0.9)", color: "white", padding: "12px 20px", borderRadius: "5px", zIndex: "2000", transition: "opacity 0.5s", opacity: "1", boxShadow: "0 4px 10px rgba(0,0,0,0.2)" }), document.body.appendChild(n), setTimeout(() => { n.style.opacity = "0", setTimeout(() => n.remove(), 500) }, 3e3) }

    async function handleData(response) {
      document.getElementById('loader-overlay').style.display = 'none';
      allTabConfigs.forEach(config => { document.getElementById(config.controls.refreshBtn).innerHTML = '<span class="refresh-icon">‚Üª</span> Load' });
      allData = [], staffFilteredData = [], japanData = [], leaderData = [], mentionedData = [], hcmData = [], hanoiData = [];
      // clearPendingChanges(); // MODIFIED: Do not clear changes on load to persist them

      if (response.error || !Array.isArray(response.rows)) {
        const errorMsg = 'L·ªói ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu: ' + (response.error || 'ƒê·ªãnh d·∫°ng d·ªØ li·ªáu kh√¥ng ƒë√∫ng');
        allTabConfigs.forEach(config => showError(errorMsg, config.table.body));
        return;
      }
      allData = response.rows.sort((a, b) => (parseDateString(b["Ng√†y l√™n ƒë∆°n"] || b["Th·ªùi gian l√™n ƒë∆°n"]) || 0) - (parseDateString(a["Ng√†y l√™n ƒë∆°n"] || a["Th·ªùi gian l√™n ƒë∆°n"]) || 0));
      generateDatalistOptions();
      const staffId = getUrlParameter('id');
      const mentionedStaffIds = (getUrlParameter('id1') || '').split(',').filter(id => id.trim() !== '');
      if (!staffId) {
        showError('Thi·∫øu tham s·ªë ID nh√¢n vi√™n trong URL', mainTabConfig.table.body);
      } else {
        try {
          currentStaff = await fetchStaffInfo(staffId);
          let staffInfo = `Nh√¢n vi√™n: ${currentStaff.ho_va_ten}`;
          if (currentStaff.vi_tri === "Leader" || currentStaff.vi_tri === "L√™n bill") staffInfo += ` (Leader - Team ${currentStaff.team})`;
          document.getElementById('userInfo').textContent = staffInfo;
          if (currentStaff.vi_tri_van_don === "L√™n ƒë∆°n FFM" && !editableCols.includes("ƒê∆°n v·ªã v·∫≠n chuy·ªÉn")) {
            editableCols.push("ƒê∆°n v·ªã v·∫≠n chuy·ªÉn");
          }
          if (currentStaff?.vi_tri === "Leader" || currentStaff?.vi_tri === "L√™n bill") {
            document.getElementById('tabLeader').style.display = '';
            leaderData = allData.filter(row => (row["NV V·∫≠n ƒë∆°n"] || row["NV_V·∫≠n_ƒë∆°n"]) === currentStaff.ho_va_ten);
            initializeTab(leaderTabConfig, leaderData);
          }
          if (currentStaff.vi_tri_van_don === "L√™n ƒë∆°n FFM") {
            const staffBranch = currentStaff.chi_nhanh;
            if (staffBranch === "HCM") {
              document.getElementById('tabHCM').style.display = '';
              hcmData = allData.filter(row => (row.Team || '') === 'HCM' && row["ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"] == "" && row["K·∫øt qu·∫£ Check"] == "OK");
              initializeTab(hcmTabConfig, hcmData);
            } else if (staffBranch === "H√† N·ªôi") {
              document.getElementById('tabHanoi').style.display = '';
              hanoiData = allData.filter(row => (row.Team || '') === 'H√† N·ªôi' && row["ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"] == "" && row["K·∫øt qu·∫£ Check"] == "OK");
              initializeTab(hanoiTabConfig, hanoiData);
            }
          }
          if (currentStaff?.vi_tri == 'Leader' || currentStaff?.vi_tri === "L√™n bill") {
            const staffBranch = currentStaff.chi_nhanh;
            if (staffBranch === "HCM") {
              document.getElementById('tabHCM').style.display = '';
              staffFilteredData = allData.filter(row => (row.Team || '') === 'HCM');
            } else if (staffBranch === "H√† N·ªôi") {
              document.getElementById('tabHanoi').style.display = '';
              staffFilteredData = allData.filter(row => (row.Team || '') === 'H√† N·ªôi');
            }
          } else {
            staffFilteredData = allData.filter(row => {
              return row["NV V·∫≠n ƒë∆°n"] === currentStaff.ho_va_ten
            });
          }

          initializeTab(mainTabConfig, staffFilteredData);
        } catch (error) {
          showError(error.message, mainTabConfig.table.body);
        }
      }
      if (mentionedStaffIds.length > 0) {
        document.getElementById('tabMentioned').style.display = '';
        try {
          const mentionedStaffNames = await fetchMultipleStaffInfo(mentionedStaffIds);
          if (mentionedStaffNames.length > 0) {
            mentionedData = allData.filter(row => mentionedStaffNames.includes(row["NV V·∫≠n ƒë∆°n"] || row["NV_V·∫≠n_ƒë∆°n"]));
            initializeTab(mentionedTabConfig, mentionedData);
          } else {
            showError('Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n n√†o cho c√°c ID ƒë∆∞·ª£c cung c·∫•p trong tham s·ªë id1.', 'mentionedTableBody');
          }
        } catch (error) { }
      }
      japanData = allData.filter(row => (row['khu v·ª±c'] || row['Khu v·ª±c']) === 'Nh·∫≠t B·∫£n');
      initializeTab(japanTabConfig, japanData);

      updateStatusButtonUI(); // MODIFIED: Update button state after data is handled
    }
    function initializeTab(config, data) { generateDynamicOptions(config, data); populateExternalFilters(config); renderHeader(config); renderTableBody(config, data); applyAllFilters(config); setupCellSelection(config.table.body); }
    function generateDynamicOptions(config, data) { const options = {}; columnsToMakeDynamic.forEach(colName => { if (dropdownCols[colName]) { options[colName] = dropdownCols[colName].filter(opt => opt !== "").sort((a, b) => String(a).localeCompare(String(b), 'vi')); } else { const dataKey = columnDisplayMapping[colName] || colName; const valueMapper = row => { const val = row[dataKey] || row[dataKey.replace(/ /g, '_')] || (dataKey === 'khu v·ª±c' ? row['Khu v·ª±c'] || '' : ''); return typeof val === 'string' ? val.trim() : val; }; const uniqueValues = new Set(data.map(valueMapper).filter(Boolean)); options[colName] = Array.from(uniqueValues).sort((a, b) => String(a).localeCompare(String(b), 'vi')); } }); if (config === mainTabConfig) dynamicFilterOptions = options; else if (config === japanTabConfig) japanDynamicFilterOptions = options; else if (config === leaderTabConfig) leaderDynamicFilterOptions = options; else if (config === mentionedTabConfig) mentionedDynamicFilterOptions = options; else if (config === hcmTabConfig) hcmDynamicFilterOptions = options; else if (config === hanoiTabConfig) hanoiDynamicFilterOptions = options; }
    function populateExternalFilters(config) { const options = config.dynamicOptions(); const productFilter = document.getElementById(config.controls.product); productFilter.innerHTML = '<option value="">T·∫•t c·∫£ s·∫£n ph·∫©m</option>'; (options['M·∫∑t h√†ng'] || []).forEach(opt => productFilter.add(new Option(opt, opt))); if (config.controls.market) { const marketFilter = document.getElementById(config.controls.market); marketFilter.innerHTML = '<option value="">T·∫•t c·∫£ khu v·ª±c</option>'; (options['khu v·ª±c'] || []).forEach(opt => marketFilter.add(new Option(opt, opt))) } if (config.controls.staff) { const staffFilter = document.getElementById(config.controls.staff); staffFilter.innerHTML = '<option value="">T·∫•t c·∫£ NV V·∫≠n ƒë∆°n</option>'; (options['NV V·∫≠n ƒë∆°n'] || []).forEach(opt => staffFilter.add(new Option(opt, opt))) } }
    function generateDatalistOptions() { datalistOptions = {}; datalistFilterCols.forEach(colName => { const dataKey = columnDisplayMapping[colName] || colName; const uniqueValues = new Set(allData.map(row => row[dataKey] || row[dataKey.replace(/ /g, '_')]).filter(Boolean)); datalistOptions[colName] = Array.from(uniqueValues) }) }
    function parseDateStringFilter(dateString) {
      const parts = dateString.split('/');
      // L∆∞u √Ω: th√°ng trong JavaScript b·∫Øt ƒë·∫ßu t·ª´ 0 (0 l√† th√°ng 1, 1 l√† th√°ng 2,...)
      // V√¨ v·∫≠y, ch√∫ng ta c·∫ßn tr·ª´ ƒëi 1 t·ª´ gi√° tr·ªã th√°ng.
      const day = parseInt(parts[0], 10);
      const month = parseInt(parts[1], 10) - 1;
      const year = parseInt(parts[2], 10);
      return new Date(year, month, day);
    }

    // =========================================================================
    // === H√ÄM ƒê∆Ø·ª¢C T·ªêI ∆ØU H√ìA - applyAllFilters ===
    // =========================================================================
    function applyAllFilters(config) {
      const tableHead = document.getElementById(config.table.head);
      const tableBody = document.getElementById(config.table.body);
      if (!tableHead.querySelector('tr') || !tableBody) return;

      // Thu th·∫≠p t·∫•t c·∫£ ƒëi·ªÅu ki·ªán l·ªçc
      const startDateVal = document.getElementById(config.controls.startDate).value;
      const endDateVal = document.getElementById(config.controls.endDate).value;
      const start = startDateVal ? new Date(startDateVal) : null;
      const end = endDateVal ? new Date(endDateVal) : null;
      if (start) start.setHours(0, 0, 0, 0);
      if (end) end.setHours(23, 59, 59, 999);

      const productValue = document.getElementById(config.controls.product).value;
      const marketValue = config.controls.market ? document.getElementById(config.controls.market).value : '';
      const staffValue = config.controls.staff ? document.getElementById(config.controls.staff).value : '';

      const filterValues = {};
      tableHead.querySelectorAll('[data-column]').forEach(filter => {
        const colName = filter.dataset.column;
        if (!filterValues[colName]) filterValues[colName] = {};
        if (filter.dataset.filterType) {
          filterValues[colName][filter.dataset.filterType] = filter.value.toLowerCase();
        } else if (filter.classList.contains('multi-select-container')) {
          const selected = Array.from(filter.querySelectorAll('input:checked:not(.select-all-cb)')).map(cb => cb.value);
          if (selected.length > 0) filterValues[colName].multi = new Set(selected);
        } else if (filter.tagName === 'SELECT') {
          if (filter.value) filterValues[colName].single = filter.value;
        } else if (filter.classList.contains('filter-input')) {
          filterValues[colName].text = filter.value.toLowerCase();
        }
      });

      // üî• THAY ƒê·ªîI CH√çNH: L·ªçc tr√™n d·ªØ li·ªáu g·ªëc thay v√¨ DOM
      const originalData = config.data();

      // L·ªçc d·ªØ li·ªáu g·ªëc
      const filteredData = originalData.filter((rowData, rowIndex) => {
        let isVisible = true;

        // L·ªçc theo ng√†y
        if (start || end) {
          const orderDate = parseDateStringFilter(rowData["Ng√†y l√™n ƒë∆°n"] || rowData["Th·ªùi gian l√™n ƒë∆°n"]);
          if (!orderDate || (start && orderDate < start) || (end && orderDate > end)) {
            isVisible = false;
          }
        }

        // L·ªçc theo s·∫£n ph·∫©m, khu v·ª±c, nh√¢n vi√™n
        if (isVisible && productValue && (rowData["M·∫∑t h√†ng"] || '') !== productValue) isVisible = false;
        if (isVisible && marketValue && (rowData["Khu v·ª±c"] || rowData["khu v·ª±c"] || '') !== marketValue) isVisible = false;
        if (isVisible && staffValue && (rowData["NV V·∫≠n ƒë∆°n"] || rowData["NV_V·∫≠n_ƒë∆°n"] || '') !== staffValue) isVisible = false;

        // L·ªçc theo c√°c c·ªôt kh√°c
        if (isVisible) {
          for (const colName in filterValues) {
            const dataKey = columnDisplayMapping[colName] || colName;
            let cellValue = rowData[dataKey] ?? (rowData[dataKey.replace(/ /g, '_')] || (dataKey === 'khu v·ª±c' ? (rowData['Khu v·ª±c'] || '') : ''));
            const cellValueLower = String(cellValue).toLowerCase();
            const colFilters = filterValues[colName];

            // L·ªçc theo tr·∫°ng th√°i (empty/not-empty/numeric-start)
            if (colFilters.state) {
              const valueString = String(cellValue).trim();
              const isBlank = !valueString;
              if (colFilters.state === 'empty') {
                if (!isBlank) {
                  isVisible = false;
                  break;
                }
              } else if (colFilters.state === 'not-empty') {
                if (isBlank) {
                  isVisible = false;
                  break;
                }
              } else if (colFilters.state === 'numeric-start') {
                if (isBlank || !/^\d/.test(valueString)) {
                  isVisible = false;
                  break;
                }
              }
            }

            // C√°c b·ªô l·ªçc kh√°c
            if (colFilters.text && !cellValueLower.includes(colFilters.text)) {
              isVisible = false;
              break;
            }
            if (colFilters.single && String(cellValue) !== colFilters.single) {
              isVisible = false;
              break;
            }
            if (colFilters.multi) {
              const valueAsString = String(cellValue).trim();
              const isBlank = !valueAsString;
              const isMatch = (colFilters.multi.has('') && isBlank) || colFilters.multi.has(valueAsString);
              if (!isMatch) {
                isVisible = false;
                break;
              }
            }
            if (colFilters.contains && !cellValueLower.includes(colFilters.contains)) {
              isVisible = false;
              break;
            }
            if (colFilters.notcontains && colFilters.notcontains !== '' && cellValueLower.includes(colFilters.notcontains)) {
              isVisible = false;
              break;
            }
          }
        }

        return isVisible;
      });

      // üî• RENDER L·∫†I B·∫¢NG v·ªõi d·ªØ li·ªáu ƒë√£ l·ªçc
      renderTableBody(config, filteredData);
      updateSummaryInfo(config);

      // üîß FIX: Clear selectedCells sau khi filter ƒë·ªÉ tr√°nh confusion
      // selectedCells.forEach(cell => cell.classList.remove("cell-selected"));
      // selectedCells.clear();
      // console.log('üîÑ Cleared selectedCells after filter');

      // C·∫≠p nh·∫≠t sticky columns v√† cell selection
      setTimeout(() => {
        updateStickyColumns(config);
        setupCellSelection(config.table.body);
      }, 10);
    }

    // =========================================================================
    // === H√ÄM ƒê√É ƒê∆Ø·ª¢C CH·ªàNH S·ª¨A - renderHeader ===
    // =========================================================================
    function renderHeader(config) {
      const header = document.getElementById(config.table.head);
      const options = config.dynamicOptions();
      header.innerHTML = '';
      const tr = document.createElement('tr');
      const fixedCount = getFixedColumnCount();
      const debouncedFilter = () => { clearTimeout(filterDebounceTimer); filterDebounceTimer = setTimeout(() => applyAllFilters(config), 300) };
      const immediateFilter = () => applyAllFilters(config);
      displayColumns.forEach((colName, index) => {
        const th = document.createElement('th');
        th.textContent = colName;
        if (index < fixedCount) th.classList.add('fixed-column');
        th.appendChild(document.createElement('br'));

        if (colName === "M√£ Tracking") {
          const container = document.createElement('div');
          container.className = 'tracking-filter-container';

          const selectState = document.createElement('select');
          selectState.className = 'filter-select';
          selectState.style.marginBottom = '4px';
          selectState.dataset.column = colName;
          selectState.dataset.filterType = 'state';

          selectState.add(new Option('T√¨nh tr·∫°ng m√£', ''));
          selectState.add(new Option('T·∫•t c·∫£ c√≥ m√£', 'not-empty'));
          selectState.add(new Option('Tr·ªëng', 'empty'));
          // THAY ƒê·ªîI B·∫ÆT ƒê·∫¶U: Th√™m t√πy ch·ªçn "To√†n s·ªë"
          selectState.add(new Option('To√†n s·ªë', 'numeric-start'));
          // THAY ƒê·ªîI K·∫æT TH√öC
          selectState.addEventListener('change', immediateFilter);

          const inputContains = document.createElement('input');
          inputContains.type = 'text';
          inputContains.placeholder = 'Ch·ª©a k√Ω t·ª±...';
          inputContains.className = 'filter-input';
          inputContains.dataset.column = colName;
          inputContains.dataset.filterType = 'contains';
          inputContains.addEventListener('input', debouncedFilter);

          const inputNotContains = document.createElement('input');
          inputNotContains.type = 'text';
          inputNotContains.placeholder = 'Kh√¥ng ch·ª©a...';
          inputNotContains.className = 'filter-input';
          inputNotContains.dataset.column = colName;
          inputNotContains.dataset.filterType = 'notcontains';
          inputNotContains.addEventListener('input', debouncedFilter);

          container.append(selectState, inputContains, inputNotContains);
          th.appendChild(container);

        } else if (singleSelectFilterCols.includes(colName) && options[colName]) {
          const filterElement = document.createElement('select');
          filterElement.className = 'filter-select';
          filterElement.dataset.column = colName;
          filterElement.add(new Option(`T·∫•t c·∫£ ${colName}`, ''));
          options[colName].forEach(opt => filterElement.add(new Option(opt, opt)));
          filterElement.addEventListener('change', immediateFilter);
          th.appendChild(filterElement)
        } else if (options[colName]) {
          const container = document.createElement('div');
          container.className = 'multi-select-container';
          container.dataset.column = colName;
          const button = document.createElement('button');
          button.className = 'multi-select-button';
          button.textContent = `T·∫•t c·∫£ ${colName}`;
          const dropdown = document.createElement('div');
          dropdown.className = 'checkbox-dropdown';
          const selectAllLabel = document.createElement('label');
          const selectAllCheckbox = document.createElement('input');
          selectAllCheckbox.type = 'checkbox';
          selectAllCheckbox.className = 'select-all-cb';
          selectAllLabel.style.fontWeight = 'bold';
          selectAllLabel.style.borderBottom = '1px solid #ccc';
          selectAllLabel.style.marginBottom = '4px';
          selectAllLabel.append(selectAllCheckbox, ' (T·∫•t c·∫£)');
          dropdown.appendChild(selectAllLabel);
          const createCheckbox = (value, text) => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.value = value;
            checkbox.addEventListener('change', () => {
              const allOptionCheckboxes = Array.from(dropdown.querySelectorAll('input[type="checkbox"]:not(.select-all-cb)'));
              selectAllCheckbox.checked = allOptionCheckboxes.every(cb => cb.checked);
              const selectedCount = dropdown.querySelectorAll('input:checked:not(.select-all-cb)').length;
              button.textContent = selectedCount === 0 ? `T·∫•t c·∫£ ${colName}` : `${selectedCount} l·ª±a ch·ªçn`; immediateFilter();
            });
            label.append(checkbox, ` ${text}`);
            return label;
          };
          dropdown.appendChild(createCheckbox('', '(Tr·ªëng)'));
          options[colName].forEach(opt => dropdown.appendChild(createCheckbox(opt, opt)));
          selectAllCheckbox.addEventListener('change', (e) => {
            dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = e.target.checked);
            const selectedCount = e.target.checked ? dropdown.querySelectorAll('input:checked:not(.select-all-cb)').length : 0;
            button.textContent = selectedCount === 0 ? `T·∫•t c·∫£ ${colName}` : `${selectedCount} l·ª±a ch·ªçn`;
            immediateFilter();
          });
          button.addEventListener('click', e => {
            e.stopPropagation();
            document.querySelectorAll('.checkbox-dropdown.show').forEach(d => { if (d !== dropdown) d.classList.remove('show') });
            dropdown.classList.toggle('show')
          });
          container.append(button, dropdown);
          th.appendChild(container)
        } else if (datalistFilterCols.includes(colName)) {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'filter-input';
          input.placeholder = `L·ªçc ${colName}...`;
          input.dataset.column = colName;
          const datalistId = `datalist-${colName.replace(/[^a-zA-Z0-9]/g, '-')}`;
          input.setAttribute('list', datalistId);
          const datalist = document.createElement('datalist');
          datalist.id = datalistId;
          if (datalistOptions[colName]) {
            datalistOptions[colName].forEach(opt => {
              const option = document.createElement('option');
              option.value = opt; datalist.appendChild(option)
            })
          }
          input.addEventListener('input', debouncedFilter);
          th.append(input, datalist)
        } else {
          const filterElement = document.createElement('input');
          filterElement.type = 'text';
          filterElement.className = 'filter-input';
          filterElement.placeholder = `L·ªçc ${colName}...`;
          filterElement.dataset.column = colName;
          filterElement.addEventListener('input', debouncedFilter);
          th.appendChild(filterElement)
        }
        tr.appendChild(th)
      });
      header.appendChild(tr);
      window.addEventListener('click', e => {
        if (!e.target.closest('.multi-select-container')) {
          document.querySelectorAll('.checkbox-dropdown.show').forEach(d => d.classList.remove('show'))
        }
      })
    }

    function renderTableBody(config, data) {
      const container = document.getElementById(config.table.body);
      container.innerHTML = '';
      if (data.length === 0) {
        showError(`Kh√¥ng c√≥ ƒë∆°n h√†ng n√†o.`, config.table.body);
        return;
      }

      const fixedCount = getFixedColumnCount();
      const originalData = config.data(); // M·∫£ng d·ªØ li·ªáu g·ªëc

      data.forEach((row, filteredIndex) => {
        const tr = document.createElement('tr');
        
        // üî• FIX: T√¨m originalRowIndex trong m·∫£ng g·ªëc
        const originalRowIndex = originalData.findIndex(originalRow => 
          originalRow["M√£ ƒë∆°n h√†ng"] === row["M√£ ƒë∆°n h√†ng"]
        );
        
        tr.dataset.filteredIndex = filteredIndex; // Index trong m·∫£ng ƒë√£ l·ªçc
        tr.dataset.originalRowIndex = originalRowIndex; // Index trong m·∫£ng g·ªëc
        
        displayColumns.forEach((col, colIndex) => {
          const td = document.createElement('td');
          if (colIndex < fixedCount) td.classList.add('fixed-column');
          if (longTextColumns.includes(col)) {
            td.classList.add('long-text-cell');
          }
          
          const dataKey = columnDisplayMapping[col] || col;
          let value;
          if (allDateColumns.includes(dataKey)) {
            let dateSource = row[dataKey] || '';
            if (dataKey === "Ng√†y l√™n ƒë∆°n") dateSource = row["Ng√†y l√™n ƒë∆°n"] || row["Th·ªùi gian l√™n ƒë∆°n"];
            const formattedDate = formatDate(dateSource);
            value = formattedDate.display;
            td.dataset.originalValue = formattedDate.original;
          } else if (dataKey === "Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2") {
            const dateVal = row[dataKey];
            if (dateVal) {
              value = dateVal
            } else {
              value = '';
            }
          } else {
            value = row[dataKey] ?? (row[dataKey.replace(/ /g, '_')] || (dataKey === 'khu v·ª±c' ? (row['Khu v·ª±c'] || '') : ''));
          }
          
          if (editableCols.includes(col)) {
            td.classList.add('editable');
            if (dropdownCols[col]) {
              td.classList.add('has-dropdown');
              const select = document.createElement('select');
              const validOptions = dropdownCols[col];
              validOptions.forEach(opt => select.add(new Option(opt, opt)));
              if (validOptions.includes(value)) {
                select.value = value;
              } else {
                select.value = "";
              }
              select.addEventListener('change', (e) => {
                // üî• FIX: Ki·ªÉm tra xem c√≥ ƒëang trong qu√° tr√¨nh bulk clear kh√¥ng
                if (e.target.dataset.isBulkClear) {
                  // N·∫øu ƒëang trong qu√° tr√¨nh bulk clear, ch·ªâ c·∫≠p nh·∫≠t d·ªØ li·ªáu local, kh√¥ng g·ªçi API
                  delete e.target.dataset.isBulkClear; // X√≥a flag sau khi s·ª≠ d·ª•ng
                  return;
                }
                
                td.classList.add('highlight');
                const newValue = select.value;
                
                
                // üî• FIX: L·∫•y primaryKey tr·ª±c ti·∫øp t·ª´ DOM (c·ªôt ƒë·∫ßu ti√™n)
                const primaryKey = getOrderCodeFromCell(td);
                
                if (primaryKey && primaryKey !== 'N/A') {
                  // C·∫≠p nh·∫≠t d·ªØ li·ªáu JavaScript
                  const filteredIdx = parseInt(tr.dataset.filteredIndex);
                  const originalIdx = parseInt(tr.dataset.originalRowIndex);
                  
                  // C·∫≠p nh·∫≠t m·∫£ng ƒë√£ l·ªçc
                  if (data[filteredIdx]) {
                    data[filteredIdx][col] = newValue;
                  }
                  
                  // C·∫≠p nh·∫≠t m·∫£ng g·ªëc
                  if (originalIdx >= 0 && originalData[originalIdx]) {
                    originalData[originalIdx][col] = newValue;
                  }
                  
                  // C·∫≠p nh·∫≠t allData n·∫øu c·∫ßn
                  if (allData && allData.length > 0) {
                    const allDataIndex = allData.findIndex(item => item["M√£ ƒë∆°n h√†ng"] === primaryKey);
                    if (allDataIndex !== -1) {
                      allData[allDataIndex][col] = newValue;
                    }
                  }
                  
                  const updates = { [col]: newValue };
                  if (col === 'ƒê∆°n v·ªã v·∫≠n chuy·ªÉn') {
                    const timestamp = getDateTimeVN();
                    updates["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                    
                    // C·∫≠p nh·∫≠t t·∫•t c·∫£ m·∫£ng d·ªØ li·ªáu
                    if (data[filteredIdx]) data[filteredIdx]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                    if (originalIdx >= 0 && originalData[originalIdx]) originalData[originalIdx]["Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2"] = timestamp;
                    
                    // C·∫≠p nh·∫≠t giao di·ªán
                    const dateColIndex = displayColumns.indexOf("Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2");
                    if (dateColIndex > -1 && tr.cells[dateColIndex]) {
                      tr.cells[dateColIndex].textContent = timestamp;
                      tr.cells[dateColIndex].classList.add('highlight');
                    }
                  }
                  
                  processCellUpdate(primaryKey, updates);
                } else {
                  console.error('‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c primary key t·ª´ DOM!');
                }
              });
              td.appendChild(select);
            } else {
              td.textContent = value;
            }
          } else {
            td.textContent = value;
          }
          
          if (col === "K·∫øt qu·∫£ Check") {
            if (value === 'OK') td.classList.add('cell-ok');
            else if (value === 'V·∫≠n ƒë∆°n XL') td.classList.add('cell-xl');
            else if (value === 'Hu·ª∑') td.classList.add('cell-cancel');
          }
          tr.appendChild(td);
        });
        container.appendChild(tr);
      });
      
      updateStickyColumns(config);
    }
    function setupControls() {
      setupTabs();
      allTabConfigs.forEach(setupTabControls);
      document.getElementById('fixedColumnCountInput').addEventListener('input', handleFixedColumnCountChange);

      // MODIFIED: Add listeners for popover
      document.getElementById('statusButton').addEventListener('click', showStatusPopover);
      document.querySelector('.close-popover').addEventListener('click', hideStatusPopover);
      document.getElementById('status-popover').addEventListener('click', (e) => {
        if (e.target.id === 'status-popover') hideStatusPopover();
      });
      document.getElementById('update-all-pending').addEventListener('click', handleUpdateAllPending);
      document.getElementById('cancel-all-changes').addEventListener('click', handleCancelAllChanges);

      document.addEventListener('keydown', e => {
        const activeEl = document.activeElement;
        if (activeEl && ['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) && !activeEl.closest('td')) return;
        if (document.querySelector('td.editing')) return;
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c' && selectedCells.size > 0) { e.preventDefault(); copySelectedCells() }
        else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v' && selectedCells.size > 0) { e.preventDefault(); navigator.clipboard.readText().then(text => pasteToSelectedCells(text)).catch(err => console.error('L·ªói ƒë·ªçc clipboard:', err)) }
        else if ((e.key === 'Delete' || e.key === 'Backspace') && selectedCells.size > 0) { 
          // console.log('üóëÔ∏è Delete/Backspace key pressed'); 
          // console.log('Selected cells size:', selectedCells.size);
          e.preventDefault(); 
          clearSelectedCells() 
        }
        // === THAY TH·∫æ/TH√äM LOGIC CTRL+ENTER N√ÄY ===
        else if (e.key === 'Enter' && e.ctrlKey) {
          e.preventDefault();
          areLongTextFieldsExpanded = !areLongTextFieldsExpanded;
          toggleAllLongTextCells(areLongTextFieldsExpanded);
        }
        // === K·∫æT TH√öC ===
      });

      window.addEventListener('resize', () => {
        const activeTab = document.querySelector('.content-tab.active'); if (!activeTab) return;
        const activeConfig = allTabConfigs.find(c => c.table.body === activeTab.querySelector('tbody')?.id);
        if (activeConfig) updateStickyColumns(activeConfig)
      });
    }
    function setupTabControls(config) { document.getElementById(config.controls.refreshBtn).addEventListener('click', refreshData); document.getElementById(config.controls.updateBtn).addEventListener('click', () => processBulkUpdate(config)); const filterFunction = () => applyAllFilters(config); document.getElementById(config.controls.startDate).addEventListener('change', filterFunction); document.getElementById(config.controls.endDate).addEventListener('change', filterFunction); document.getElementById(config.controls.product).addEventListener('change', filterFunction); if (config.controls.market) document.getElementById(config.controls.market).addEventListener('change', filterFunction); if (config.controls.staff) document.getElementById(config.controls.staff).addEventListener('change', filterFunction); document.getElementById(config.controls.clearBtn).addEventListener('click', () => { document.getElementById(config.controls.startDate).value = ''; document.getElementById(config.controls.endDate).value = ''; document.getElementById(config.controls.product).selectedIndex = 0; if (config.controls.market) document.getElementById(config.controls.market).selectedIndex = 0; if (config.controls.staff) document.getElementById(config.controls.staff).selectedIndex = 0; const header = document.getElementById(config.table.head); header.querySelectorAll('.filter-input').forEach(f => f.value = ''); header.querySelectorAll('.filter-select').forEach(f => f.selectedIndex = 0); header.querySelectorAll('.multi-select-container').forEach(container => { container.querySelectorAll('input:checked').forEach(cb => cb.checked = !1); container.querySelector('.multi-select-button').textContent = `T·∫•t c·∫£ ${container.dataset.column}` }); applyAllFilters(config) }) }
    function refreshData() { loadData() }
    function setupTabs() {
      const tabs = document.querySelectorAll('.tab-btn'),
        contents = document.querySelectorAll('.content-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          selectedCells.forEach(cell => cell.classList.remove('cell-selected'));
          selectedCells.clear();
          isMouseDown = !1;
          startCell = null;
          tabs.forEach(item => item.classList.remove('active'));
          contents.forEach(content => content.classList.remove('active'));
          tab.classList.add('active');
          const contentId = 'content' + tab.id.substring(3);
          document.getElementById(contentId).classList.add('active');
          setTimeout(() => {
            handleFixedColumnCountChange();
            const summaryEl = document.getElementById('selectionSummary');
            if (summaryEl) summaryEl.innerHTML = contentId === 'contentData' ? '' : '';
          }, 10)
          refreshData()
        })
      })
    }
    

    async function processBulkUpdate(config) {
      const pendingChanges = getPendingChanges();
      const payload = Object.values(pendingChanges);

      if (payload.length === 0) {
        showTempMessage('Kh√¥ng c√≥ thay ƒë·ªïi n√†o trong kho ƒë·ªÉ c·∫≠p nh·∫≠t.', true);
        return;
      }

      const updateBtn = document.getElementById(config.controls.updateBtn);
      updateBtn.disabled = true;
      updateBtn.textContent = 'ƒêang x·ª≠ l√Ω...';

      try {
        const response = await fetch(UPDATE_BULK_URL, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (!response.ok || !result.success) {
          throw new Error(result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server');
        }
        showTempMessage(`C·∫≠p nh·∫≠t h√†ng lo·∫°t th√†nh c√¥ng ${result.summary.updated} ƒë∆°n h√†ng.`);
        clearPendingChanges();
      } catch (error) {
        console.error("L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t:", error);
        showTempMessage(`L·ªói c·∫≠p nh·∫≠t. Vui l√≤ng li√™n h·ªá l·∫≠p tr√¨nh vi√™n.`, true);
      } finally {
        updateBtn.disabled = false;
        updateBtn.textContent = 'C·∫≠p nh·∫≠t';
      }
    }

    async function loadData() {
      const { email, tuNgay, denNgay, tableName, id1 } = Object.fromEntries(new URLSearchParams(window.location.search));
      document.getElementById('loader-overlay').style.display = 'flex';
      allTabConfigs.forEach(config => showError('ƒêang t·∫£i d·ªØ li·ªáu...', config.table.body));
      try {
        // Pre-fetch all staff data
        await fetchAllStaffData();
        const url = `https://n-api-eight.vercel.app/sheet/getAll?email=${email}&${tuNgay ? `tuNgay=${tuNgay}&` : ''}${denNgay ? `denNgay=${denNgay}&` : ''}${tableName ? `tableName=${tableName}` : ''}`;
        const response = await fetch(url);
        const data = await response.json();
        handleData(data);
      } catch (error) {
        console.error('Error loading data:', error);
        document.getElementById('loader-overlay').style.display = 'none';
        allTabConfigs.forEach(config => showError('L·ªói khi t·∫£i d·ªØ li·ªáu: ' + error.message, config.table.body));
      }
    }

    document.addEventListener('DOMContentLoaded', () => { setupControls(); loadData() });
  </script>
</body>

</html>

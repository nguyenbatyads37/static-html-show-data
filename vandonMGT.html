<!DOCTYPE html>
<html lang="vi">


<head>
    <meta charset="UTF-8">
    <title>Qu·∫£n l√Ω ƒë∆°n h√†ng SPEEGO</title>
    <style>
        :root {
            --filter-row-height: 38px;
            /* --- B·∫£ng m√†u chuy√™n nghi·ªáp --- */
            --primary-color: #003366;
            /* Xanh coban ƒë·∫≠m */
            --accent-color: #f39c12;
            /* Cam */
            --header-text-color: #ffffff;
            --background-color: #f4f7fa;
            --border-color: #dfe6e9;
            --text-color: #2d3436;
            --light-text-color: #636e72;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            user-select: none;
        }

        /* --- Header v·ªõi Logo --- */
        .header-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .header-container img {
            height: 50px;
            border-radius: 5px;
        }

        h2 {
            text-align: center;
            margin: 0;
            color: var(--primary-color);
            font-weight: 600;
        }

        .main-filters {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            flex-wrap: wrap;
            border: 1px solid var(--border-color);
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 180px; /* Th√™m ƒë·ªÉ gi·ªØ chi·ªÅu r·ªông ·ªïn ƒë·ªãnh */
        }

        .filter-group label {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: var(--light-text-color);
        }

        .filter-group select,
        .filter-group input {
            padding: 6px 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 14px;
            background-color: #fff;
        }

        td select.editable-select {
            width: 100%;
            border: none;
            background: transparent;
            font-family: inherit;
            font-size: inherit;
            padding: 0;
            margin: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        td.editable-dropdown-cell {
            padding: 0;
        }

        td.editable-dropdown-cell select.editable-select {
            padding: 8px 12px;
        }

        .tab-container {
            margin-bottom: 15px;
            padding: 5px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            border: 1px solid var(--border-color);
        }

        .tab-btn {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #ecf0f1;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s;
            font-weight: 500;
        }

        .tab-btn:hover {
            background-color: #dfe6e9;
            border-color: #b2bec3;
        }

        .tab-btn.active {
            background-color: var(--primary-color);
            color: var(--header-text-color);
            border-color: var(--primary-color);
            font-weight: bold;
        }

        .tab-btn.tracking-tab {
            background-color: #e74c3c;
            color: white;
        }

        .tab-btn.tracking-tab.active {
            background-color: #c0392b;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            align-items: center;
            background: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.07);
            position: sticky;
            top: 0;
            z-index: 100;
            border: 1px solid var(--border-color);
        }

        .controls>div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-wrapper {
            position: relative;
            overflow: auto;
            max-height: 65vh;
            background: white;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
            border: 1px solid var(--border-color);
        }

        table {
            border-collapse: collapse;
            width: 100%;
            min-width: 1900px;
            font-size: 14px;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th,
        td {
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            text-align: left;
            white-space: nowrap;
            background-color: white;
        }

        th {
            background-color: var(--primary-color);
            color: var(--header-text-color);
            top: var(--filter-row-height);
            z-index: 20;
            font-weight: 500;
        }

        #filterRow th {
            top: 0;
            background-color: #f2f6fa;
            padding: 4px 8px;
        }

        .filter-input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 13px;
        }

        .dual-filter-container {
            display: flex;
            gap: 4px;
            align-items: center;
            flex-direction: column;
        }

        td.editable {
            background-color: #fffbe8;
        }

        button {
            padding: 6px 12px;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            transition: background-color 0.3s, transform 0.1s;
            font-weight: 500;
        }

        button:hover {
            background-color: #004a80;
            color: white;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        #downloadExcel {
            background-color: #16a085;
        }

        #downloadExcel:hover {
            background-color: #1abc9c;
        }

        .highlight {
            background-color: #ffeb3b !important;
        }

        .fixed-column {
            position: sticky;
            z-index: 5;
            background-color: #fcfcfc;
        }

        th.fixed-column {
            z-index: 30;
            background-color: var(--primary-color);
        }

        #filterRow th.fixed-column {
            z-index: 40;
            background-color: #e9ecef;
        }

        td.fixed-column {
            background-color: white;
        }

        .status-ok {
            background-color: #d4edda;
            color: #155724;
            font-weight: bold;
        }

        .status-cancel {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }

        td.cell-selected {
            background-color: rgba(0, 51, 102, 0.3) !important;
        }

        td.paste-anchor {
            outline: 2px solid #e74c3c !important;
            outline-offset: -2px;
        }

        .order-counter b {
            color: #e74c3c;
            font-size: 16px;
            padding: 0 4px;
        }

        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            pointer-events: none;
        }

        .toast {
            background: white;
            padding: 12px 16px;
            margin-bottom: 10px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 350px;
            min-width: 200px;
            transform: translateX(400px);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
            pointer-events: auto;
            border-left: 4px solid var(--primary-color);
            font-size: 14px;
            color: #333;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.info {
            border-left-color: var(--primary-color);
        }

        .toast.success {
            border-left-color: #2ecc71;
        }

        .toast.error {
            border-left-color: #e74c3c;
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            gap: 10px;
            border: 1px solid var(--border-color);
        }

        .pagination-controls button {
            padding: 8px 15px;
            background-color: var(--primary-color);
        }

        .pagination-controls button:hover:not(:disabled) {
            background-color: #004a80;
        }

        .pagination-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        #syncChangesBtn {
            background-color: var(--accent-color);
            position: relative;
        }

        #syncChangesBtn:hover {
            background-color: #e67e22;
        }

        .changes-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #e74c3c;
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            min-width: 18px;
            text-align: center;
            line-height: 14px;
            display: none;
        }

        .multiselect-filter {
            position: relative;
            width: 100%;
        }

        .multiselect-display {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: white;
            font-size: 13px;
            cursor: pointer;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--light-text-color);
        }

        /* --- S·ª≠a l·∫°i style cho button c·ªßa main filter --- */
        .main-filters .multiselect-display {
            padding: 6px 10px;
            font-size: 14px;
            height: 22px; /* ƒê·ªìng b·ªô chi·ªÅu cao */
            line-height: 22px;
        }

        .multiselect-dropdown {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
            width: 200px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 101; /* N·ªïi tr√™n c√°c control kh√°c */
            margin-top: 2px;
        }

        .multiselect-dropdown.show {
            display: block;
        }

        .multiselect-item {
            display: block;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-color);
        }

        .multiselect-item:hover {
            background-color: #f0f0f0;
        }

        .multiselect-item input {
            margin-right: 8px;
        }

        #clearFiltersBtn {
            background-color: #e74c3c;
            border-color: #e74c3c;
            transition: all 0.3s ease;
        }

        #clearFiltersBtn:hover {
            background-color: #c0392b !important;
        }
    </style>
</head>

<body>
    <div class="header-container">
        <img src="https://www.appsheet.com/template/gettablefileurl?appName=Appsheet-325045268&tableName=Kho%20%E1%BA%A3nh&fileName=Kho%20%E1%BA%A3nh_Images%2Fbe61f44f.%E1%BA%A2nh.021347.png"
            alt="SPEEGO Logo">
        <h2>Qu·∫£n l√Ω ƒë∆°n h√†ng SPEEGO</h2>
    </div>

    <div id="mainFilters" class="main-filters">
        <!-- --- M·ªöI: B·ªô l·ªçc Th·ªã tr∆∞·ªùng d·∫°ng tickbox --- -->
        <div class="filter-group">
            <label for="filterMarket">Th·ªã tr∆∞·ªùng</label>
            <div id="marketFilterContainer" class="multiselect-filter"></div>
        </div>
        <!-- --- M·ªöI: B·ªô l·ªçc S·∫£n ph·∫©m d·∫°ng tickbox --- -->
        <div class="filter-group">
            <label for="filterProduct">S·∫£n ph·∫©m</label>
            <div id="productFilterContainer" class="multiselect-filter"></div>
        </div>
        <div class="filter-group">
            <label for="filterDateFrom">T·ª´ ng√†y</label>
            <input type="date" id="filterDateFrom">
        </div>
        <div class="filter-group">
            <label for="filterDateTo">T·ªõi ng√†y</label>
            <input type="date" id="filterDateTo">
        </div>
        <div class="filter-group" style="min-width: auto;">
            <label for="fixedColumns">S·ªë c·ªôt c·ªë ƒë·ªãnh</label>
            <input type="number" id="fixedColumns" value="1" min="0" style="width: 60px;">
        </div>
        <div class="filter-group" style="min-width: auto;">
            <label>&nbsp;</label>
            <button id="clearFiltersBtn">
                üóëÔ∏è X√≥a l·ªçc
            </button>
        </div>
    </div>

    <div id="tabContainer" class="tab-container"></div>

    <div class="controls">
        <div>
            <button id="refreshData" class="refresh-btn">
                <span class="refresh-icon">‚Üª</span> Load d·ªØ li·ªáu
            </button>
            <button id="syncChangesBtn">
                Tr·∫°ng th√°i thay ƒë·ªïi
                <span id="changesBadge" class="changes-badge">0</span>
            </button>
            <button id="updateAll">C·∫≠p nh·∫≠t t·∫•t c·∫£ thay ƒë·ªïi</button>
            <button id="downloadExcel">T·∫£i Excel</button>
            <span id="orderCounter" class="order-counter"></span>
            <span id="selectionSummary" class="selection-summary"></span>
        </div>
        <div>
            <button id="toggleTrackingView" class="tab-btn tracking-tab">Xem ƒë∆°n c√≥ m√£ Tracking</button>
            <button id="toggleDuplicateTrackingView" class="tab-btn tracking-tab">Xem ƒë∆°n tr√πng M√£ tracking</button>
            <button id="transferWarehouseBtn" class="tab-btn" disabled
                style="display: none; background-color: var(--accent-color); color: white;">Chuy·ªÉn kho</button>
        </div>
    </div>

    <div class="table-wrapper" id="tableContainer">
        <table>
            <thead>
                <tr id="filterRow"></tr>
                <tr>
                    <th>M√£ ƒë∆°n h√†ng</th>
                    <th>Ng√†y l√™n ƒë∆°n</th>
                    <th>Name*</th>
                    <th>Phone*</th>
                    <th>Add</th>
                    <th>City</th>
                    <th>State</th>
                    <th>Khu v·ª±c</th>
                    <th>Zipcode</th>
                    <th>M·∫∑t h√†ng</th>
                    <th>T√™n m·∫∑t h√†ng 1</th>
                    <th>S·ªë l∆∞·ª£ng m·∫∑t h√†ng 1</th>
                    <th>T√™n m·∫∑t h√†ng 2</th>
                    <th>S·ªë l∆∞·ª£ng m·∫∑t h√†ng 2</th>
                    <th>Qu√† t·∫∑ng</th>
                    <th>S·ªë l∆∞·ª£ng qu√† k√®m</th>
                    <th>Gi√° b√°n</th>
                    <th>Lo·∫°i ti·ªÅn thanh to√°n</th>
                    <th>T·ªïng ti·ªÅn VNƒê</th>
                    <th>H√¨nh th·ª©c thanh to√°n</th>
                    <th>Ghi ch√∫</th>
                    <th>Ghi ch√∫ v·∫≠n ƒë∆°n</th>
                    <th>K·∫øt qu·∫£ check</th>
                    <th>M√£ Tracking</th>
                    <th>Ng√†y ƒë√≥ng h√†ng</th>
                    <th>Tr·∫°ng th√°i giao h√†ng</th>
                    <th>GHI CH√ö</th>
                    <th>Th·ªùi gian giao d·ª± ki·∫øn</th>
                    <th>Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2</th>
                    <th>Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)</th>
                    <th>Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <div id="paginationControls" class="pagination-controls">
        <button id="prevPage">Trang tr∆∞·ªõc</button>
        <span id="pageInfo" class="pagination-info">Trang 1/1</span>
        <button id="nextPage">Trang sau</button>
        <div class="pagination-page-size">
            <label for="rowsPerPageSelect">S·ªë d√≤ng/trang:</label>
            <select id="rowsPerPageSelect">
                <option value="50">50</option>
                <option value="70" selected>70</option>
                <option value="100">100</option>
                <option value="200">200</option>
                <option value="500">500</option>
            </select>
        </div>
    </div>

    <div id="toastContainer" class="toast-container"></div>

    <div id="syncPopover" class="popover-overlay" style="display:none;">
        <div class="popover-container">
            <div class="popover-header">
                <h4>Qu·∫£n l√Ω c√°c thay ƒë·ªïi ƒëang ch·ªù</h4>
                <button id="closePopoverBtn" class="popover-close">&times;</button>
            </div>
            <div id="popoverBody" class="popover-body"></div>
            <div class="popover-footer">
                <button id="discardAllChangesBtn" style="background-color: #e74c3c;">H·ªßy b·ªè t·∫•t c·∫£</button>
                <button id="applyAllChangesBtn" style="background-color: #2ecc71;">L∆∞u t·∫•t c·∫£</button>
            </div>
        </div>
    </div>

    <script>
        const prod = 'https://n-api-gamma.vercel.app'
        const localhost = 'http://localhost:8081'
        const host = 'prod'
        const mainHost = host === 'prod' ? prod : localhost
        const SHEET_NAME = 'F3';
        const BATCH_UPDATE_API_URL = `${mainHost}/sheet/${SHEET_NAME}/update?verbose=true`;
        const SINGLE_UPDATE_API_URL = `${mainHost}/sheet/${SHEET_NAME}/update-single`;
        const TRANSFER_API_URL = `${mainHost}/sheet/MGT n·ªôi b·ªô/rows/batch`;
        const MGT_NOI_BO_ORDER_API_URL = `${mainHost}/sheet/MGT n·ªôi b·ªô/data`;

        const TEAM_COLUMN_NAME = "Team";
        const PRIMARY_KEY_COLUMN = "M√£ ƒë∆°n h√†ng";

        const displayColumns = ["M√£ ƒë∆°n h√†ng", "Ng√†y l√™n ƒë∆°n", "Name*", "Phone*", "Add", "City", "State", "Khu v·ª±c", "Zipcode", "M·∫∑t h√†ng", "T√™n m·∫∑t h√†ng 1", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 1", "T√™n m·∫∑t h√†ng 2", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 2", "Qu√† t·∫∑ng", "S·ªë l∆∞·ª£ng qu√† k√®m", "Gi√° b√°n", "Lo·∫°i ti·ªÅn thanh to√°n", "T·ªïng ti·ªÅn VNƒê", "H√¨nh th·ª©c thanh to√°n", "Ghi ch√∫", "Ghi ch√∫ v·∫≠n ƒë∆°n", "K·∫øt qu·∫£ check", "M√£ Tracking", "Ng√†y ƒë√≥ng h√†ng", "Tr·∫°ng th√°i giao h√†ng", "GHI CH√ö", "Th·ªùi gian giao d·ª± ki·∫øn", "Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2", "Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)", "Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)"];
        const columnMapping = { "Ghi ch√∫ v·∫≠n ƒë∆°n": "ng√†y h·∫πn ƒë·∫©y ƒë∆°n", "K·∫øt qu·∫£ check": "K·∫øt qu·∫£ Check" };
        const editableCols = ["K·∫øt qu·∫£ check", "M√£ Tracking", "Ng√†y ƒë√≥ng h√†ng", "Tr·∫°ng th√°i giao h√†ng", "Th·ªùi gian giao d·ª± ki·∫øn", "Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)", "Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)", "GHI CH√ö"];
        const checkStatusOptions = ["", "OK", "Hu·ª∑", "Ch·ªù check l·∫°i", "Sai SƒêT", "Sai ƒë·ªãa ch·ªâ", "Kh√°c"];

        let state = { allData: [], legacyChanges: new Map(), pendingChanges: new Map(), activeTeam: 'all', showTrackingOrders: false, showDuplicateTrackingOrders: false, filterValues: {}, mgtNoiBoOrder: [], isMgtNoiBoOrderLoading: false, currentPage: 1, rowsPerPage: 70, totalFilteredOrders: 0, mainFilterValues: { market: [], product: [] } };
        let pasteAnchorCell = null;
        let isUpdatingSingleCell = false;
        let isPasting = false;

        function showCustomAlert(message, type = 'info', duration = 3000) { const container = document.getElementById('toastContainer'); const toast = document.createElement('div'); toast.className = `toast ${type}`; const messageSpan = document.createElement('span'); messageSpan.textContent = message; const closeBtn = document.createElement('button'); closeBtn.className = 'toast-close'; closeBtn.innerHTML = '√ó'; closeBtn.onclick = () => removeToast(toast); toast.appendChild(messageSpan); toast.appendChild(closeBtn); container.appendChild(toast); setTimeout(() => { toast.classList.add('show'); }, 10); if (duration > 0) { setTimeout(() => { removeToast(toast); }, duration); } return toast; }
        function removeToast(toast) { if (!toast || !toast.parentNode) return; toast.classList.remove('show'); setTimeout(() => { if (toast.parentNode) { toast.parentNode.removeChild(toast); } }, 300); }
        function formatDate(dateString) { if (!dateString) return ''; try { const date = new Date(dateString.includes('Z') ? dateString : dateString + 'Z'); if (isNaN(date.getTime())) return dateString; const day = String(date.getDate()).padStart(2, '0'); const month = String(date.getMonth() + 1).padStart(2, '0'); const year = date.getFullYear(); return `${day}/${month}/${year}`; } catch (e) { return dateString; } }
        function parseDateToISO(dateString) { if (!dateString || dateString.length === 0) return ''; const parts = dateString.split('/'); if (parts.length === 3) { const day = parseInt(parts[0], 10); const month = parseInt(parts[1], 10) - 1; const year = parseInt(parts[2], 10); const date = new Date(year, month, day); if (!isNaN(date.getTime())) { return date.toISOString().split('T')[0]; } } return dateString; }
        function updateOrderCounter(count) { const counterElement = document.getElementById('orderCounter'); if (counterElement) { counterElement.innerHTML = `T·ªïng s·ªë ƒë∆°n: <b>${count}</b>`; } }
        function savePendingChangesToLocalStorage() { const serializableChanges = {}; const allChanges = new Map([...state.legacyChanges, ...state.pendingChanges]); allChanges.forEach((colChanges, orderId) => { serializableChanges[orderId] = {}; colChanges.forEach((changeInfo, colName) => { serializableChanges[orderId][colName] = { newValue: changeInfo.newValue, originalValue: changeInfo.originalValue, }; }); }); localStorage.setItem('speegoPendingChanges', JSON.stringify(serializableChanges)); updateSyncButtonBadge(); }
        function loadPendingChangesFromLocalStorage() { const storedChanges = localStorage.getItem('speegoPendingChanges'); if (storedChanges) { try { const parsedChanges = JSON.parse(storedChanges); state.legacyChanges.clear(); for (const orderId in parsedChanges) { const colChangesMap = new Map(); for (const colName in parsedChanges[orderId]) { colChangesMap.set(colName, { newValue: parsedChanges[orderId][colName].newValue, originalValue: parsedChanges[orderId][colName].originalValue, cellElement: null }); } state.legacyChanges.set(orderId, colChangesMap); } updateSyncButtonBadge(); } catch (e) { console.error("L·ªói khi ƒë·ªçc l·ªãch s·ª≠ thay ƒë·ªïi t·ª´ localStorage:", e); localStorage.removeItem('speegoPendingChanges'); } } }
        function handleData(response) { document.getElementById('refreshData').disabled = false; document.getElementById('refreshData').innerHTML = '<span class="refresh-icon">‚Üª</span> Load d·ªØ li·ªáu'; state.allData = []; if (response.error) { showCustomAlert(`L·ªói t·∫£i d·ªØ li·ªáu: ${response.error}`, 'error'); return; } const data = response.rows || response.data || response; if (!Array.isArray(data)) { showCustomAlert('D·ªØ li·ªáu tr·∫£ v·ªÅ kh√¥ng h·ª£p l·ªá.', 'error'); return; } state.allData = data; loadPendingChangesFromLocalStorage(); const initialDataForFilters = filterByCarrier(state.allData); populateMainFilters(initialDataForFilters); createTabs(initialDataForFilters); setupColumnFilters(); if (state.activeTeam === 'mgt_noi_bo' && state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) { fetchMGTNoiBoOrder().then(render); } else { render(); } }
        function filterByCarrier(data) { return data.filter(row => { const carrier = row["ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"] || row["ƒê∆°n_v·ªã_v·∫≠n_chuy·ªÉn"]; return carrier?.toString().toUpperCase() === "MGT"; }); }
        async function fetchMGTNoiBoOrder() { if (state.isMgtNoiBoOrderLoading) return; state.isMgtNoiBoOrderLoading = true; const loadingToast = showCustomAlert('ƒêang t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô...', 'info', 0); try { const response = await fetch(MGT_NOI_BO_ORDER_API_URL); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const json = await response.json(); if (json.data && Array.isArray(json.data)) { state.mgtNoiBoOrder = json.data.map(row => row[PRIMARY_KEY_COLUMN]).filter(Boolean); removeToast(loadingToast); showCustomAlert('ƒê√£ t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô.', 'success', 2000); } else { state.mgtNoiBoOrder = []; removeToast(loadingToast); showCustomAlert('Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.', 'error'); } } catch (e) { console.error('L·ªói khi t·∫£i d·ªØ li·ªáu MGT N·ªôi B·ªô:', e); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi khi t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô: ${e.message}`, 'error'); state.mgtNoiBoOrder = []; } finally { state.isMgtNoiBoOrderLoading = false; } }

        function createMainMultiSelectFilter(containerId, columnKey, columnName, data) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; 

            const ALL_OPTION_TEXT = 'T·∫•t c·∫£';
            const EMPTY_OPTION_TEXT = '(Tr·ªëng)';
            const EMPTY_OPTION_VALUE = '__EMPTY__';

            const display = document.createElement('button');
            display.className = 'multiselect-display';

            const dropdown = document.createElement('div');
            dropdown.className = 'multiselect-dropdown';

            container.appendChild(display);
            container.appendChild(dropdown);

            const uniqueValues = [...new Set(data.map(row => (row[columnKey] || '').trim()).filter(Boolean))].sort();
            const options = [ALL_OPTION_TEXT, EMPTY_OPTION_TEXT, ...uniqueValues];
            let selectedValues = state.mainFilterValues[containerId === 'marketFilterContainer' ? 'market' : 'product'];

            const updateDisplay = () => {
                if (selectedValues.length === 0 || selectedValues.length === (uniqueValues.length + 1)) {
                    display.textContent = `T·∫•t c·∫£ ${columnName}`;
                } else if (selectedValues.length === 1) {
                    display.textContent = selectedValues[0] === EMPTY_OPTION_VALUE ? EMPTY_OPTION_TEXT : selectedValues[0];
                } else {
                    display.textContent = `${selectedValues.length} ${columnName.toLowerCase()} ƒë√£ ch·ªçn`;
                }
            };

            dropdown.innerHTML = '';
            options.forEach(optionText => {
                const item = document.createElement('div');
                item.className = 'multiselect-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                const label = document.createElement('label');
                const optionId = `main-filter-${columnKey}-${optionText.replace(/\s/g, '_')}`;
                checkbox.id = optionId;
                label.htmlFor = optionId;
                label.textContent = optionText;
                let optionValue = optionText === EMPTY_OPTION_TEXT ? EMPTY_OPTION_VALUE : optionText;
                checkbox.checked = (optionText === ALL_OPTION_TEXT) ? selectedValues.length === (uniqueValues.length + 1) : selectedValues.includes(optionValue);
                item.appendChild(checkbox);
                item.appendChild(label);
                dropdown.appendChild(item);
            });
            
            updateDisplay();

            dropdown.addEventListener('change', (e) => {
                const targetCheckbox = e.target;
                const optionText = targetCheckbox.parentElement.textContent;
                let optionValue = optionText === EMPTY_OPTION_TEXT ? EMPTY_OPTION_VALUE : optionText;
                const stateKey = containerId === 'marketFilterContainer' ? 'market' : 'product';

                if (optionText === ALL_OPTION_TEXT) {
                    selectedValues = [];
                    if (targetCheckbox.checked) {
                        dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                            cb.checked = true;
                            const text = cb.parentElement.textContent;
                            if (text !== ALL_OPTION_TEXT) {
                                selectedValues.push(text === EMPTY_OPTION_TEXT ? EMPTY_OPTION_VALUE : text);
                            }
                        });
                    } else {
                        dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                    }
                } else {
                    if (targetCheckbox.checked) {
                        if (!selectedValues.includes(optionValue)) selectedValues.push(optionValue);
                    } else {
                        selectedValues = selectedValues.filter(v => v !== optionValue);
                    }
                    dropdown.querySelector('input[type="checkbox"]').checked = selectedValues.length === uniqueValues.length + 1;
                }
                
                state.mainFilterValues[stateKey] = selectedValues;
                updateDisplay();
                state.currentPage = 1;
                setupColumnFilters();
                render();
            });

            dropdown.addEventListener('click', e => e.stopPropagation());
            display.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.multiselect-dropdown.show').forEach(d => { if (d !== dropdown) d.classList.remove('show'); });
                dropdown.classList.toggle('show');
            });
        }

        function populateMainFilters(data) {
            createMainMultiSelectFilter('marketFilterContainer', 'Khu v·ª±c', 'Th·ªã tr∆∞·ªùng', data);
            createMainMultiSelectFilter('productFilterContainer', 'M·∫∑t h√†ng', 'S·∫£n ph·∫©m', data);
        }

        function getMainFilteredData() {
            let data = filterByCarrier([...state.allData]);
            
            // L·ªçc theo Th·ªã tr∆∞·ªùng (Khu v·ª±c)
            const selectedMarkets = state.mainFilterValues.market;
            if (selectedMarkets.length > 0) {
                data = data.filter(row => {
                    const cellValue = (row['Khu v·ª±c'] || '').trim();
                    if (cellValue === '' && selectedMarkets.includes('__EMPTY__')) return true;
                    return selectedMarkets.includes(cellValue);
                });
            }

            // L·ªçc theo S·∫£n ph·∫©m (M·∫∑t h√†ng)
            const selectedProducts = state.mainFilterValues.product;
            if (selectedProducts.length > 0) {
                 data = data.filter(row => {
                    const cellValue = (row['M·∫∑t h√†ng'] || '').trim();
                    if (cellValue === '' && selectedProducts.includes('__EMPTY__')) return true;
                    return selectedProducts.includes(cellValue);
                });
            }

            const dateFrom = document.getElementById('filterDateFrom').value;
            const dateTo = document.getElementById('filterDateTo').value;

            if (dateFrom) { const from = new Date(dateFrom); from.setHours(0, 0, 0, 0); data = data.filter(row => row["Ng√†y l√™n ƒë∆°n"] && new Date(row["Ng√†y l√™n ƒë∆°n"]) >= from); }
            if (dateTo) { const to = new Date(dateTo); to.setHours(23, 59, 59, 999); data = data.filter(row => row["Ng√†y l√™n ƒë∆°n"] && new Date(row["Ng√†y l√™n ƒë∆°n"]) <= to); }
            if (state.activeTeam === 'mgt_noi_bo') { const orderedIds = new Set(state.mgtNoiBoOrder); data = data.filter(row => orderedIds.has(row["M√£ ƒë∆°n h√†ng"])); } else if (state.activeTeam !== 'all') { data = data.filter(row => row[TEAM_COLUMN_NAME] === state.activeTeam); }
            
            return data;
        }

        function getFilteredData() {
            let dataToRender = getMainFilteredData();
            const trackingIncludeRaw = state.filterValues['tracking_include'] || '';
            const trackingExcludeRaw = state.filterValues['tracking_exclude'] || '';
            const otherColumnFilters = Object.entries(state.filterValues).filter(([key, val]) => !key.startsWith('tracking_') && ((Array.isArray(val) && val.length > 0) || (typeof val === 'string' && val.trim() !== '')));

            if (otherColumnFilters.length > 0) {
                dataToRender = dataToRender.filter(row => {
                    return otherColumnFilters.every(([col, filterValue]) => {
                        const dataKey = columnMapping[col] || col;
                        const cellValue = (row[dataKey] ?? row[col] ?? row[dataKey.replace(/ /g, '_')] ?? '').toString().trim();
                        if (Array.isArray(filterValue)) { const EMPTY_OPTION_VALUE = '__EMPTY__'; if (filterValue.length === 0) return true; const hasEmptyFilter = filterValue.includes(EMPTY_OPTION_VALUE); if (cellValue === '' && hasEmptyFilter) return true; if (filterValue.includes(cellValue)) return true; return false; } else { return cellValue.toLowerCase().includes(filterValue.toLowerCase()); }
                    });
                });
            }

            if (trackingIncludeRaw || trackingExcludeRaw) { const lowerInclude = trackingIncludeRaw.toLowerCase(); const lowerExclude = trackingExcludeRaw.toLowerCase(); dataToRender = dataToRender.filter(row => { const cellValue = String(row['M√£ Tracking'] || ''); const lowerCellValue = cellValue.toLowerCase(); if (lowerExclude && lowerCellValue.includes(lowerExclude)) { return false; } if (lowerInclude) { if (lowerInclude.includes('\n')) { const codes = new Set(trackingIncludeRaw.split('\n').map(t => t.trim()).filter(Boolean)); if (!codes.has(cellValue.trim())) return false; } else { if (!lowerCellValue.includes(lowerInclude)) return false; } } return true; }); }
            if (state.showDuplicateTrackingOrders) { const trackingCounts = new Map(); dataToRender.forEach(row => { const trackingCode = String(row["M√£ Tracking"] || '').trim(); if (trackingCode) { trackingCounts.set(trackingCode, (trackingCounts.get(trackingCode) || 0) + 1); } }); const duplicateTrackings = new Set(); for (const [code, count] of trackingCounts.entries()) { if (count > 1) { duplicateTrackings.add(code); } } dataToRender = dataToRender.filter(row => { const trackingCode = String(row["M√£ Tracking"] || '').trim(); return duplicateTrackings.has(trackingCode); }); } else { dataToRender = dataToRender.filter(row => { const trackingCode = String(row["M√£ Tracking"] || row["M√£_Tracking"] || ''); return state.showTrackingOrders ? trackingCode.trim() !== '' : !trackingCode.trim(); }); }
            if (state.activeTeam === 'mgt_noi_bo') { const orderIndexMap = new Map(state.mgtNoiBoOrder.map((id, index) => [id, index])); dataToRender.sort((a, b) => { const indexA = orderIndexMap.get(a[PRIMARY_KEY_COLUMN]); const indexB = orderIndexMap.get(b[PRIMARY_KEY_COLUMN]); return indexA - indexB; }); } else { const primarySortKey = 'Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2'; const secondarySortKey = PRIMARY_KEY_COLUMN; dataToRender.sort((a, b) => { const parseDate = (val) => { if (!val) return null; const date = new Date(val); return isNaN(date.getTime()) ? null : date; }; const dateA = parseDate(a[primarySortKey]); const dateB = parseDate(b[primarySortKey]); if (dateA === null && dateB === null) { } else if (dateA === null) { return 1; } else if (dateB === null) { return -1; } else { const dateComparison = dateA.getTime() - dateB.getTime(); if (dateComparison !== 0) { return dateComparison; } } const orderIdA = a[secondarySortKey] || ''; const orderIdB = b[secondarySortKey] || ''; return orderIdA.localeCompare(orderIdB); }); }
            state.totalFilteredOrders = dataToRender.length;
            const startIndex = (state.currentPage - 1) * state.rowsPerPage;
            return dataToRender.slice(startIndex, startIndex + state.rowsPerPage);
        }

        function render() {
            const tableContainer = document.getElementById('tableContainer');
            const scrollPos = tableContainer.scrollTop;

            const paginatedData = getFilteredData();
            const container = document.getElementById('tableBody');
            container.innerHTML = '';
            if (paginatedData.length === 0) { let message = 'Kh√¥ng c√≥ d·ªØ li·ªáu ph√π h·ª£p'; if (state.activeTeam === 'mgt_noi_bo' && state.isMgtNoiBoOrderLoading) { message = 'ƒêang t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô...'; } container.innerHTML = `<tr><td colspan="${displayColumns.length}" class="no-data">${message}</td></tr>`; updateOrderCounter(state.totalFilteredOrders); updatePaginationControls(); return; }
            updateOrderCounter(state.totalFilteredOrders);
            paginatedData.forEach((row) => {
                const tr = document.createElement('tr'); const orderId = row[PRIMARY_KEY_COLUMN]; tr.dataset.orderId = orderId;
                displayColumns.forEach(col => {
                    const td = document.createElement('td'); const dataKey = columnMapping[col] || col; const originalValue = String(row[dataKey] ?? row[col] ?? row[col.replace(/ /g, '_')] ?? ''); const pendingChange = state.pendingChanges.get(orderId)?.get(dataKey) || state.legacyChanges.get(orderId)?.get(dataKey); let displayValue = pendingChange ? pendingChange.newValue : originalValue;
                    if (["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"].includes(col)) { displayValue = formatDate(displayValue); }
                    if (col === "Ghi ch√∫ v·∫≠n ƒë∆°n" && displayValue) { td.classList.add('note-highlight'); }
                    const checkValue = String(displayValue).trim().toLowerCase(); td.classList.remove('status-ok', 'status-cancel');
                    if (col === "K·∫øt qu·∫£ check") { if (checkValue === 'ok') td.classList.add('status-ok'); else if (checkValue.includes('hu·ª∑')) td.classList.add('status-cancel'); }
                    if (editableCols.includes(col)) {
                        td.classList.add('editable'); if (pendingChange) { td.classList.add('highlight'); pendingChange.cellElement = td; } else { td.classList.remove('highlight'); }
                        const handleCellChange = (newValue, element) => {
                            if (isUpdatingSingleCell) return; let finalValueForState = newValue; if (col === "Ng√†y ƒë√≥ng h√†ng" && newValue) { finalValueForState = new Date(newValue).toLocaleDateString('en-US'); } else { finalValueForState = String(newValue); }
                            const originalRowData = state.allData.find(r => r[PRIMARY_KEY_COLUMN] === orderId); const trueOriginalValue = originalRowData ? String(originalRowData[dataKey] ?? '') : ''; const isChanged = finalValueForState !== trueOriginalValue;
                            if (isChanged) { if (!state.pendingChanges.has(orderId)) { state.pendingChanges.set(orderId, new Map()); } const changeInfo = { newValue: finalValueForState, originalValue: trueOriginalValue, cellElement: td }; state.pendingChanges.get(orderId).set(dataKey, changeInfo); td.classList.add('highlight'); savePendingChangesToLocalStorage(); const isTrackingColumn = col === "M√£ Tracking"; if (!isPasting && !isTrackingColumn) { handleSingleCellUpdate(orderId, dataKey, finalValueForState, td); } else if (isTrackingColumn) { showCustomAlert('Thay ƒë·ªïi M√£ Tracking ƒë√£ ƒë∆∞·ª£c l∆∞u. Vui l√≤ng b·∫•m "C·∫≠p nh·∫≠t t·∫•t c·∫£" ƒë·ªÉ g·ª≠i d·ªØ li·ªáu.', 'info', 4000); } } else { const orderChanges = state.pendingChanges.get(orderId); if (orderChanges) { orderChanges.delete(dataKey); if (orderChanges.size === 0) state.pendingChanges.delete(orderId); } const legacyOrderChanges = state.legacyChanges.get(orderId); if (legacyOrderChanges) { legacyOrderChanges.delete(dataKey); if (legacyOrderChanges.size === 0) state.legacyChanges.delete(orderId); } td.classList.remove('highlight'); savePendingChangesToLocalStorage(); } updateSelectionSummary();
                        };
                        if (col === "K·∫øt qu·∫£ check") {
                            td.classList.add('editable-dropdown-cell'); const select = document.createElement('select'); select.className = 'editable-select'; const currentVal = String(displayValue); const optionsToAdd = new Set(checkStatusOptions); if (currentVal && !optionsToAdd.has(currentVal)) { optionsToAdd.add(currentVal); } Array.from(optionsToAdd).sort().forEach(opt => { const option = document.createElement('option'); option.value = opt; option.textContent = opt; if (opt.toLowerCase() === currentVal.toLowerCase()) { option.selected = true; } select.appendChild(option); }); select.addEventListener('change', () => { handleCellChange(select.value, select); const selectedVal = select.value.toLowerCase(); td.classList.remove('status-ok', 'status-cancel'); if (selectedVal === 'ok') td.classList.add('status-ok'); else if (selectedVal.includes('hu·ª∑')) td.classList.add('status-cancel'); }); td.innerHTML = ''; td.appendChild(select);
                        } else if (col === "Ng√†y ƒë√≥ng h√†ng") {
                            const input = document.createElement('input'); input.type = 'date'; input.className = 'date-input'; try { if (displayValue) { const dateParts = displayValue.split('/'); if (dateParts.length === 3) { input.value = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`; } else if (new Date(displayValue) != "Invalid Date") { input.value = new Date(displayValue).toISOString().split('T')[0]; } } } catch (e) { } td.style.padding = '0'; input.style.padding = '8px 12px'; input.addEventListener('change', () => handleCellChange(input.value, input)); input.addEventListener('blur', () => handleCellChange(input.value, input)); td.innerHTML = ''; td.appendChild(input);
                        } else { td.contentEditable = 'true'; td.textContent = displayValue; td.addEventListener('blur', () => handleCellChange(td.textContent, td)); }
                    } else { td.textContent = displayValue; }
                    tr.appendChild(td);
                }); container.appendChild(tr);
            });
            updateFixedColumns();
            updatePaginationControls();
            tableContainer.scrollTop = scrollPos;
        }

        // --- C√°c h√†m c√≤n l·∫°i gi·ªØ nguy√™n code g·ªëc ƒë√£ ch·∫°y ·ªïn ƒë·ªãnh ---
        function updateFixedColumns() { const numFixed = parseInt(document.getElementById('fixedColumns').value, 10); const table = document.querySelector('.table-wrapper table'); if (!table) return; const rows = Array.from(table.rows); rows.forEach(row => { Array.from(row.cells).forEach(cell => { cell.classList.remove('fixed-column'); cell.style.left = ''; }); }); if (numFixed <= 0 || rows.length < 2) return; const headerCells = rows[1].cells; const offsets = [0]; for (let i = 1; i < numFixed; i++) { if (headerCells[i - 1]) { offsets[i] = offsets[i - 1] + headerCells[i - 1].offsetWidth; } } rows.forEach(row => { for (let i = 0; i < numFixed; i++) { const cell = row.cells[i]; if (cell) { cell.classList.add('fixed-column'); cell.style.left = `${offsets[i] || 0}px`; } } }); }
        function updatePaginationControls() { const prevBtn = document.getElementById('prevPage'); const nextPage = document.getElementById('nextPage'); const pageInfo = document.getElementById('pageInfo'); const totalPages = Math.ceil(state.totalFilteredOrders / state.rowsPerPage); pageInfo.textContent = `Trang ${state.currentPage}/${totalPages || 1}`; prevBtn.disabled = state.currentPage <= 1; nextPage.disabled = state.currentPage >= totalPages; document.getElementById('rowsPerPageSelect').value = state.rowsPerPage; }
        async function handleSingleCellUpdate(orderId, columnKey, newValue, cellElement) { if (isUpdatingSingleCell) return; isUpdatingSingleCell = true; document.getElementById('updateAll').disabled = true; const loadingToast = showCustomAlert('ƒêang c·∫≠p nh·∫≠t...', 'info', 0); try { const payload = { [PRIMARY_KEY_COLUMN]: orderId, [columnKey]: newValue }; const response = await fetch(SINGLE_UPDATE_API_URL, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!response.ok) { const errorResponse = await response.json(); throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`); } const result = await response.json(); if (result.success) { const originalRowIndex = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === orderId); if (originalRowIndex !== -1) { state.allData[originalRowIndex] = { ...state.allData[originalRowIndex], [columnKey]: newValue }; } const orderChanges = state.pendingChanges.get(orderId); if (orderChanges) { orderChanges.delete(columnKey); if (orderChanges.size === 0) { state.pendingChanges.delete(orderId); } } cellElement.classList.remove('highlight'); savePendingChangesToLocalStorage(); removeToast(loadingToast); showCustomAlert('C·∫≠p nh·∫≠t th√†nh c√¥ng!', 'success', 2000); } else { removeToast(loadingToast); showCustomAlert(`L·ªói c·∫≠p nh·∫≠t: ${result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error'); } } catch (error) { console.error('L·ªói khi c·∫≠p nh·∫≠t ƒë∆°n l·∫ª:', error); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error'); } finally { isUpdatingSingleCell = false; document.getElementById('updateAll').disabled = false; } }
        function createTabs(data) { const tabContainer = document.getElementById('tabContainer'); tabContainer.innerHTML = ''; const teams = [...new Set(data.map(row => row[TEAM_COLUMN_NAME]).filter(Boolean))].sort(); const createTab = (name, value) => { const button = document.createElement('button'); button.className = 'tab-btn'; button.textContent = name; button.dataset.team = value; if (value === state.activeTeam) { button.classList.add('active'); } button.addEventListener('click', async () => { state.activeTeam = value; state.currentPage = 1; document.querySelectorAll('#tabContainer .tab-btn').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); if (value === 'mgt_noi_bo' && state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) { await fetchMGTNoiBoOrder(); } setupColumnFilters(); render(); }); return button; }; tabContainer.appendChild(createTab('T·∫•t c·∫£', 'all')); tabContainer.appendChild(createTab('MGT n·ªôi b·ªô', 'mgt_noi_bo')); teams.forEach(team => tabContainer.appendChild(createTab(team, team))); }
        function setupColumnFilters() { const filterRow = document.getElementById('filterRow'); filterRow.innerHTML = ''; const dataForOptions = getMainFilteredData(); displayColumns.forEach((col) => { const th = document.createElement('th'); const dataKey = columnMapping[col] || col; if (col === "M√£ Tracking") { const container = document.createElement('div'); container.className = 'dual-filter-container'; const includeInput = document.createElement('input'); includeInput.type = 'text'; includeInput.className = 'filter-input'; includeInput.placeholder = 'Bao g·ªìm...'; includeInput.value = state.filterValues['tracking_include'] || ''; includeInput.addEventListener('input', () => { state.filterValues['tracking_include'] = includeInput.value; localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues)); state.currentPage = 1; render(); }); const excludeInput = document.createElement('input'); excludeInput.type = 'text'; excludeInput.className = 'filter-input'; excludeInput.placeholder = 'Lo·∫°i tr·ª´...'; excludeInput.value = state.filterValues['tracking_exclude'] || ''; excludeInput.addEventListener('input', () => { state.filterValues['tracking_exclude'] = excludeInput.value; localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues)); state.currentPage = 1; render(); }); container.appendChild(includeInput); container.appendChild(excludeInput); th.appendChild(container); } else if (col === "Tr·∫°ng th√°i giao h√†ng" || col === "M·∫∑t h√†ng") { const ALL_OPTION_TEXT = 'T·∫•t c·∫£'; const EMPTY_OPTION_TEXT = '(Tr·ªëng)'; const EMPTY_OPTION_VALUE = '__EMPTY__'; const container = document.createElement('div'); container.className = 'multiselect-filter'; const display = document.createElement('button'); display.className = 'multiselect-display'; const dropdown = document.createElement('div'); dropdown.className = 'multiselect-dropdown'; const uniqueValues = [...new Set(dataForOptions.map(row => (row[dataKey] || '').trim()).filter(Boolean))].sort(); const options = [ALL_OPTION_TEXT, EMPTY_OPTION_TEXT, ...uniqueValues]; let selectedValues = state.filterValues[dataKey] || []; const updateDisplay = () => { if (selectedValues.length === 0 || selectedValues.length === (uniqueValues.length + 1)) { display.textContent = 'L·ªçc ' + col; if (selectedValues.length === (uniqueValues.length + 1)) { state.filterValues[dataKey] = []; } } else if (selectedValues.length === 1) { display.textContent = selectedValues[0] === EMPTY_OPTION_VALUE ? EMPTY_OPTION_TEXT : selectedValues[0]; } else { display.textContent = `${selectedValues.length} ƒë√£ ch·ªçn`; } }; options.forEach(optionText => { const item = document.createElement('div'); item.className = 'multiselect-item'; const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; const label = document.createElement('label'); checkbox.id = `filter-${dataKey}-${optionText}`; label.htmlFor = `filter-${dataKey}-${optionText}`; label.textContent = optionText; let optionValue = optionText === EMPTY_OPTION_TEXT ? EMPTY_OPTION_VALUE : optionText; checkbox.checked = (optionText === ALL_OPTION_TEXT) ? selectedValues.length === (uniqueValues.length + 1) : selectedValues.includes(optionValue); item.appendChild(checkbox); item.appendChild(label); dropdown.appendChild(item); }); dropdown.addEventListener('change', (e) => { const targetCheckbox = e.target; const optionText = targetCheckbox.parentElement.textContent; let optionValue = optionText === EMPTY_OPTION_TEXT ? EMPTY_OPTION_VALUE : optionText; if (optionText === ALL_OPTION_TEXT) { const allCheckboxes = dropdown.querySelectorAll('input[type="checkbox"]'); selectedValues = []; if (targetCheckbox.checked) { allCheckboxes.forEach(cb => { cb.checked = true; const text = cb.parentElement.textContent; if (text !== ALL_OPTION_TEXT) { selectedValues.push(text === EMPTY_OPTION_TEXT ? EMPTY_OPTION_VALUE : text); } }); } else { allCheckboxes.forEach(cb => cb.checked = false); } } else { if (targetCheckbox.checked) { if (!selectedValues.includes(optionValue)) selectedValues.push(optionValue); } else { selectedValues = selectedValues.filter(v => v !== optionValue); } dropdown.querySelector(`input[id="filter-${dataKey}-${ALL_OPTION_TEXT}"]`).checked = selectedValues.length === uniqueValues.length + 1; } state.filterValues[dataKey] = selectedValues; localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues)); updateDisplay(); state.currentPage = 1; render(); }); dropdown.addEventListener('click', e => e.stopPropagation()); display.addEventListener('click', (e) => { e.stopPropagation(); document.querySelectorAll('.multiselect-dropdown.show').forEach(d => { if (d !== dropdown) d.classList.remove('show'); }); dropdown.classList.toggle('show'); }); container.appendChild(display); container.appendChild(dropdown); th.appendChild(container); updateDisplay(); } else { const input = document.createElement('input'); input.type = 'text'; input.className = 'filter-input'; input.placeholder = `L·ªçc ${col}`; input.dataset.column = col; input.value = state.filterValues[col] || ''; input.addEventListener('input', () => { state.filterValues[col] = input.value; localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues)); state.currentPage = 1; render(); }); th.appendChild(input); } filterRow.appendChild(th); }); }
        function updateSyncButtonBadge() { const badge = document.getElementById('changesBadge'); const totalChanges = state.legacyChanges.size + state.pendingChanges.size; if (totalChanges > 0) { badge.textContent = totalChanges; badge.style.display = 'block'; } else { badge.style.display = 'none'; } }
        function setupControls() { document.getElementById('refreshData').addEventListener('click', refreshData); document.getElementById('updateAll').addEventListener('click', updateAllChangedRows); document.getElementById('toggleTrackingView').addEventListener('click', () => { toggleTrackingView(); state.currentPage = 1; }); document.getElementById('toggleDuplicateTrackingView').addEventListener('click', () => { toggleDuplicateTrackingView(); state.currentPage = 1; }); const mainFilterHandler = () => { state.currentPage = 1; setupColumnFilters(); render(); }; document.getElementById('filterDateFrom').addEventListener('change', mainFilterHandler); document.getElementById('filterDateTo').addEventListener('change', mainFilterHandler); document.getElementById('downloadExcel').addEventListener('click', downloadAsExcel); document.getElementById('fixedColumns').addEventListener('change', updateFixedColumns); document.getElementById('clearFiltersBtn').addEventListener('click', clearAllFilters); document.getElementById('transferWarehouseBtn').addEventListener('click', transferSelectedOrders); document.getElementById('prevPage').addEventListener('click', () => { if (state.currentPage > 1) { state.currentPage--; render(); } }); document.getElementById('nextPage').addEventListener('click', () => { const totalPages = Math.ceil(state.totalFilteredOrders / state.rowsPerPage); if (state.currentPage < totalPages) { state.currentPage++; render(); } }); document.getElementById('rowsPerPageSelect').addEventListener('change', (e) => { state.rowsPerPage = parseInt(e.target.value, 10); state.currentPage = 1; render(); }); const popover = document.getElementById('syncPopover'); document.getElementById('syncChangesBtn').addEventListener('click', showSyncPopover); document.getElementById('closePopoverBtn').addEventListener('click', () => popover.style.display = 'none'); document.getElementById('applyAllChangesBtn').addEventListener('click', () => { updateAllChangedRows(); popover.style.display = 'none'; }); document.getElementById('discardAllChangesBtn').addEventListener('click', () => { if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën h·ªßy b·ªè T·∫§T C·∫¢ c√°c thay ƒë·ªïi ch∆∞a ƒë∆∞·ª£c l∆∞u? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) { state.pendingChanges.clear(); state.legacyChanges.clear(); localStorage.removeItem('speegoPendingChanges'); updateSyncButtonBadge(); render(); popover.style.display = 'none'; showCustomAlert('ƒê√£ h·ªßy b·ªè t·∫•t c·∫£ thay ƒë·ªïi. ƒêang t·∫£i l·∫°i d·ªØ li·ªáu...', 'info'); setTimeout(() => { refreshData(); }, 500); } }); popover.addEventListener('click', (e) => { if (e.target === popover) { popover.style.display = 'none'; } }); }
        function clearAllFilters() { state.filterValues = {}; localStorage.removeItem('speegoColumnFilters'); document.querySelectorAll('.filter-input, #filterRow select').forEach(el => el.value = ''); state.mainFilterValues = { market: [], product: [] }; populateMainFilters(filterByCarrier(state.allData)); document.getElementById('filterDateFrom').value = ''; document.getElementById('filterDateTo').value = ''; state.currentPage = 1; setupColumnFilters(); render(); showCustomAlert('ƒê√£ x√≥a t·∫•t c·∫£ b·ªô l·ªçc!', 'success'); }
        async function loadData() { document.getElementById('tableBody').innerHTML = `<tr><td colspan="${displayColumns.length}" style="text-align: center;">ƒêang t·∫£i...</td></tr>`; try { const response = await fetch(`${mainHost}/sheet/${SHEET_NAME}/data`); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); handleData(await response.json()); } catch (error) { console.error('L·ªói khi t·∫£i d·ªØ li·ªáu:', error); showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error'); document.getElementById('refreshData').disabled = false; document.getElementById('refreshData').innerHTML = '<span class="refresh-icon">‚Üª</span> Load d·ªØ li·ªáu'; } }
        async function refreshData() { if (isUpdatingSingleCell) { showCustomAlert('ƒêang c√≥ thao t√°c c·∫≠p nh·∫≠t ƒë∆°n l·∫ª, vui l√≤ng ƒë·ª£i.', 'info'); return; } const btn = document.getElementById('refreshData'); btn.disabled = true; btn.innerHTML = '<span class="refresh-icon">‚Üª</span> ƒêang t·∫£i...'; state.activeTeam = 'all'; state.filterValues = {}; localStorage.removeItem('speegoColumnFilters'); state.mainFilterValues = { market: [], product: [] }; state.mgtNoiBoOrder = []; state.currentPage = 1; state.pendingChanges.clear(); document.getElementById('tabContainer').innerHTML = ''; document.getElementById('filterRow').innerHTML = ''; document.getElementById('filterDateFrom').value = ''; document.getElementById('filterDateTo').value = ''; updateOrderCounter(0); await loadData(); }
        async function updateAllChangedRows() { if (isUpdatingSingleCell) { showCustomAlert('ƒêang c√≥ thao t√°c c·∫≠p nh·∫≠t ƒë∆°n l·∫ª, vui l√≤ng ƒë·ª£i.', 'info'); return; } const allChanges = new Map([...state.legacyChanges, ...state.pendingChanges]); if (allChanges.size === 0) { showCustomAlert('Kh√¥ng c√≥ thay ƒë·ªïi c·∫ßn c·∫≠p nh·∫≠t.', 'info'); return; } const updateBtn = document.getElementById('updateAll'); updateBtn.disabled = true; updateBtn.textContent = 'ƒêang g·ª≠i...'; const loadingToast = showCustomAlert('ƒêang c·∫≠p nh·∫≠t t·∫•t c·∫£ thay ƒë·ªïi...', 'info', 0); const rowsToSend = []; allChanges.forEach((changes, orderId) => { const changeObject = { [PRIMARY_KEY_COLUMN]: orderId }; changes.forEach((changeInfo, colName) => { changeObject[colName] = changeInfo.newValue; }); rowsToSend.push(changeObject); }); try { const response = await fetch(BATCH_UPDATE_API_URL, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(rowsToSend) }); if (!response.ok) { const errorResponse = await response.json(); throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`); } const json = await response.json(); if (json.success) { removeToast(loadingToast); showCustomAlert(`C·∫≠p nh·∫≠t th√†nh c√¥ng ${json.summary.updated} ƒë∆°n h√†ng!`, 'success'); json.details.forEach(detail => { if (detail.status === 'updated') { const updatedRowData = rowsToSend.find(r => r[PRIMARY_KEY_COLUMN] === detail.primaryKey); if (updatedRowData) { const index = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === updatedRowData[PRIMARY_KEY_COLUMN]); if (index !== -1) { state.allData[index] = { ...state.allData[index], ...updatedRowData }; } } } }); state.pendingChanges.clear(); state.legacyChanges.clear(); savePendingChangesToLocalStorage(); render(); } else { removeToast(loadingToast); showCustomAlert(`L·ªói: ${json.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error'); } } catch (error) { console.error('L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t:', error); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error'); } finally { updateBtn.disabled = false; updateBtn.textContent = 'C·∫≠p nh·∫≠t t·∫•t c·∫£ thay ƒë·ªïi'; } }
        function hasTrackingChanges(rowsToSend) { return rowsToSend.some(row => Object.keys(row).some(key => key === "M√£ Tracking" || key === "M√£_Tracking")); }
        async function batchUpdatePastedData(rowsToSend) { if (rowsToSend.length === 0) { return; } if (hasTrackingChanges(rowsToSend)) { rowsToSend.forEach(rowData => { const orderId = rowData[PRIMARY_KEY_COLUMN]; if (!orderId) return; if (!state.pendingChanges.has(orderId)) { state.pendingChanges.set(orderId, new Map()); } Object.keys(rowData).forEach(colName => { if (colName !== PRIMARY_KEY_COLUMN) { const originalRowData = state.allData.find(r => r[PRIMARY_KEY_COLUMN] === orderId); const originalValue = originalRowData ? String(originalRowData[colName] ?? '') : ''; state.pendingChanges.get(orderId).set(colName, { newValue: rowData[colName], originalValue: originalValue, cellElement: null }); } }); }); savePendingChangesToLocalStorage(); showCustomAlert(`ƒê√£ l∆∞u ${rowsToSend.length} thay ƒë·ªïi c√≥ ch·ª©a M√£ Tracking. Vui l√≤ng b·∫•m "C·∫≠p nh·∫≠t t·∫•t c·∫£" ƒë·ªÉ g·ª≠i d·ªØ li·ªáu.`, 'info', 5000); render(); return; } const updateBtn = document.getElementById('updateAll'); updateBtn.disabled = true; const loadingToast = showCustomAlert(`ƒêang c·∫≠p nh·∫≠t ${rowsToSend.length} thay ƒë·ªïi ƒë√£ d√°n...`, 'info', 0); try { const response = await fetch(BATCH_UPDATE_API_URL, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(rowsToSend) }); if (!response.ok) { const errorResponse = await response.json(); throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`); } const json = await response.json(); if (json.success) { removeToast(loadingToast); showCustomAlert(`C·∫≠p nh·∫≠t th√†nh c√¥ng ${json.summary?.updated || rowsToSend.length} ƒë∆°n h√†ng t·ª´ d·ªØ li·ªáu ƒë√£ d√°n!`, 'success'); json.details?.forEach(detail => { if (detail.status === 'updated') { const updatedRowData = rowsToSend.find(r => r[PRIMARY_KEY_COLUMN] === detail.primaryKey); if (updatedRowData) { const index = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === updatedRowData[PRIMARY_KEY_COLUMN]); if (index !== -1) { state.allData[index] = { ...state.allData[index], ...updatedRowData }; } const orderChanges = state.pendingChanges.get(updatedRowData[PRIMARY_KEY_COLUMN]); if (orderChanges) { Object.keys(updatedRowData).forEach(colName => { if (colName !== PRIMARY_KEY_COLUMN) { orderChanges.delete(colName); } }); if (orderChanges.size === 0) { state.pendingChanges.delete(updatedRowData[PRIMARY_KEY_COLUMN]); } } } } }); savePendingChangesToLocalStorage(); render(); } else { removeToast(loadingToast); showCustomAlert(`L·ªói c·∫≠p nh·∫≠t h√†ng lo·∫°t: ${json.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error'); } } catch (error) { console.error('L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t t·ª´ paste:', error); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error'); } finally { updateBtn.disabled = false; } }
        function toggleTrackingView() { state.showTrackingOrders = !state.showTrackingOrders; if (state.showTrackingOrders) { state.showDuplicateTrackingOrders = false; } updateTrackingButtonsUI(); render(); }
        function toggleDuplicateTrackingView() { state.showDuplicateTrackingOrders = !state.showDuplicateTrackingOrders; if (state.showDuplicateTrackingOrders) { state.showTrackingOrders = false; } updateTrackingButtonsUI(); render(); }
        function updateTrackingButtonsUI() { const trackingBtn = document.getElementById('toggleTrackingView'); const duplicateBtn = document.getElementById('toggleDuplicateTrackingView'); trackingBtn.textContent = state.showTrackingOrders ? 'Xem ƒë∆°n kh√¥ng c√≥ m√£ Tracking' : 'Xem ƒë∆°n c√≥ m√£ Tracking'; state.showTrackingOrders ? trackingBtn.classList.add('active') : trackingBtn.classList.remove('active'); duplicateBtn.textContent = state.showDuplicateTrackingOrders ? 'Xem t·∫•t c·∫£ ƒë∆°n' : 'Xem ƒë∆°n tr√πng M√£ tracking'; state.showDuplicateTrackingOrders ? duplicateBtn.classList.add('active') : duplicateBtn.classList.remove('active'); }
        function getCellValue(cell) { if (!cell) return ''; const select = cell.querySelector('select'); if (select) return select.value; const input = cell.querySelector('input'); return input ? input.value : cell.textContent; }
        function setCellValue(cell, value) { if (!cell) return; const select = cell.querySelector('select'); if (select) { select.value = value; select.dispatchEvent(new Event('change', { bubbles: true })); return; } const input = cell.querySelector('input'); if (input) { input.value = value; input.dispatchEvent(new Event('blur', { bubbles: true })); return; } if (cell.isContentEditable) { cell.textContent = value; cell.dispatchEvent(new Event('blur', { bubbles: true })); } }
        function clearAllSelections() { document.querySelectorAll('td.cell-selected').forEach(c => c.classList.remove('cell-selected')); if (pasteAnchorCell) { pasteAnchorCell.classList.remove('paste-anchor'); pasteAnchorCell = null; } updateSelectionSummary(); }
        function updateSelectionSummary() { const summaryEl = document.getElementById('selectionSummary'); const transferBtn = document.getElementById('transferWarehouseBtn'); const selectedCells = document.querySelectorAll('td.cell-selected'); summaryEl.innerHTML = ''; const selectedOrderIds = new Set(); const orderIdColIndex = displayColumns.indexOf(PRIMARY_KEY_COLUMN); if (selectedCells.length === 0) { transferBtn.style.display = 'none'; transferBtn.disabled = true; return; } const numericKeywords = ["s·ªë l∆∞·ª£ng", "gi√°", "ti·ªÅn", "ph√≠", "zipcode"]; const columns = new Map(); selectedCells.forEach(cell => { const colIndex = cell.cellIndex; if (colIndex === orderIdColIndex) { const orderId = getCellValue(cell).trim(); if (orderId) { selectedOrderIds.add(orderId); } } if (!columns.has(colIndex)) { columns.set(colIndex, []); } columns.get(colIndex).push(cell); }); const summaryParts = []; columns.forEach((cells, colIndex) => { const headerText = displayColumns[colIndex].toLowerCase(); const isNumeric = numericKeywords.some(kw => headerText.includes(kw)); if (isNumeric) { let sum = 0; let count = 0; cells.forEach(cell => { const value = getCellValue(cell); const num = parseFloat(String(value).replace(/[^\d.-]/g, '')); if (!isNaN(num)) { sum += num; count++; } }); if (count > 0) { summaryParts.push(`<span class="summary-item">${displayColumns[colIndex]} | Sum: <b>${sum.toLocaleString('vi-VN')}</b></span>`); } } else { let count = 0; cells.forEach(cell => { if (getCellValue(cell).trim() !== '') { count++; } }); if (count > 0) { summaryParts.push(`<span class="summary-item">${displayColumns[colIndex]} | Count: <b>${count}</b></span>`); } } }); summaryEl.innerHTML = summaryParts.join(''); if (selectedOrderIds.size > 0) { transferBtn.style.display = 'block'; transferBtn.disabled = false; } else { transferBtn.style.display = 'none'; transferBtn.disabled = true; } }
        async function transferSelectedOrders() { const transferBtn = document.getElementById('transferWarehouseBtn'); const originalText = transferBtn.textContent; transferBtn.disabled = true; transferBtn.textContent = 'ƒêang chuy·ªÉn...'; const loadingToast = showCustomAlert('ƒêang chuy·ªÉn kho...', 'info', 0); const selectedOrderIds = new Set(); const orderIdColIndex = displayColumns.indexOf(PRIMARY_KEY_COLUMN); document.querySelectorAll('td.cell-selected').forEach(cell => { if (cell.cellIndex === orderIdColIndex) { const orderId = getCellValue(cell).trim(); if (orderId) { selectedOrderIds.add({ "M√£ ƒë∆°n h√†ng": orderId }); } } }); if (selectedOrderIds.size === 0) { removeToast(loadingToast); showCustomAlert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt "M√£ ƒë∆°n h√†ng" ƒë·ªÉ chuy·ªÉn kho.', 'info'); transferBtn.disabled = false; transferBtn.textContent = originalText; return; } const maDonList = Array.from(selectedOrderIds); try { const response = await fetch(TRANSFER_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ rows: maDonList }) }); if (!response.ok) { const errorResponse = await response.json(); throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`); } const result = await response.json(); if (result && result.success) { clearAllSelections(); removeToast(loadingToast); showCustomAlert('Chuy·ªÉn kho th√†nh c√¥ng!', 'success', 2000); await fetchMGTNoiBoOrder(); render(); } else { removeToast(loadingToast); showCustomAlert(`Chuy·ªÉn kho kh√¥ng th√†nh c√¥ng: ${result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error'); } } catch (e) { console.error('L·ªói khi chuy·ªÉn kho:', e); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi ho·∫∑c x·ª≠ l√Ω: ${e.message}`, 'error'); } finally { transferBtn.disabled = false; transferBtn.textContent = originalText; } }
        function setupInteractionHandlers() { const tableBody = document.getElementById('tableBody'); if (!tableBody) return; let isSelecting = false, startCell = null; const selectCells = (start, end) => { clearAllSelections(); const tableRows = tableBody.rows; const minRow = Math.min(start.parentElement.rowIndex, end.parentElement.rowIndex); const maxRow = Math.max(start.parentElement.rowIndex, end.parentElement.rowIndex); const minCol = Math.min(start.cellIndex, end.cellIndex); const maxCol = Math.max(start.cellIndex, end.cellIndex); for (let i = 0; i < tableRows.length; i++) { const row = tableRows[i]; if (row.rowIndex >= minRow && row.rowIndex <= maxRow) { for (let j = minCol; j <= maxCol; j++) { if (row.cells[j]) row.cells[j].classList.add('cell-selected'); } } } if (start) { pasteAnchorCell = start; start.classList.add('paste-anchor'); } }; tableBody.addEventListener('mousedown', e => { if (e.button !== 0) return; const cell = e.target.closest('td'); if (!cell) return; e.preventDefault(); if (e.shiftKey && pasteAnchorCell) { selectCells(pasteAnchorCell, cell); updateSelectionSummary(); } else { isSelecting = true; clearAllSelections(); startCell = cell; pasteAnchorCell = cell; cell.classList.add('cell-selected'); cell.classList.add('paste-anchor'); updateSelectionSummary(); } }); tableBody.addEventListener('mousemove', e => { if (!isSelecting || !startCell) return; const currentCell = e.target.closest('td'); if (currentCell && currentCell !== startCell) { selectCells(startCell, currentCell); } }); document.addEventListener('mouseup', () => { if (isSelecting) { isSelecting = false; updateSelectionSummary(); } }); tableBody.addEventListener('dblclick', e => { const cell = e.target.closest('td.editable'); if (!cell) return; const input = cell.querySelector('input, select'); if (input) { input.focus(); } else if (cell.isContentEditable) { cell.focus(); document.execCommand('selectAll', false, null); document.getSelection().collapseToEnd(); } }); document.addEventListener('copy', e => { const selectedCells = document.querySelectorAll('td.cell-selected'); if (selectedCells.length === 0) return; e.preventDefault(); const rows = new Map(); selectedCells.forEach(cell => { const rowIndex = cell.parentElement.rowIndex; if (!rows.has(rowIndex)) rows.set(rowIndex, []); rows.get(rowIndex).push({ colIndex: cell.cellIndex, text: getCellValue(cell) }); }); const sortedRows = [...rows.entries()].sort((a, b) => a[0] - b[0]); const copyText = sortedRows.map(([, cells]) => cells.sort((a, b) => a.colIndex - b.colIndex).map(cell => cell.text).join('\t')).join('\n'); e.clipboardData.setData('text/plain', copyText); showCustomAlert(`ƒê√£ sao ch√©p ${selectedCells.length} √¥.`, 'info', 2000); }); document.addEventListener('paste', e => { const activeEl = document.activeElement; if (activeEl && (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) || activeEl.isContentEditable)) { return; } if (!pasteAnchorCell) return; e.preventDefault(); const pasteData = e.clipboardData.getData('text/plain'); if (!pasteData) return; const pastedRows = pasteData.split(/\r\n?|\n/).map(row => row.split('\t')); if (pastedRows.length === 0) return; if (pastedRows.length === 1 && pastedRows[0].length === 1) { const singleValue = pastedRows[0][0]; const editableSelected = document.querySelectorAll('td.cell-selected.editable'); if (editableSelected.length > 0) { const changesForBatchUpdate = new Map(); isPasting = true; editableSelected.forEach(cell => { const targetRow = cell.parentElement; const orderId = targetRow.dataset.orderId; if (!orderId) return; const colIndex = cell.cellIndex; const colName = displayColumns[colIndex]; const dataKey = columnMapping[colName] || colName; if (!editableCols.includes(colName)) return; setCellValue(cell, singleValue); if (!changesForBatchUpdate.has(orderId)) { changesForBatchUpdate.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId }); } let valueForApi = singleValue; if (colName === "Ng√†y ƒë√≥ng h√†ng") { valueForApi = parseDateToISO(singleValue); } changesForBatchUpdate.get(orderId)[dataKey] = valueForApi; }); isPasting = false; const rowsToSend = Array.from(changesForBatchUpdate.values()); if (rowsToSend.length > 0) { batchUpdatePastedData(rowsToSend); if (!hasTrackingChanges(rowsToSend)) { showCustomAlert(`ƒê√£ d√°n gi√° tr·ªã v√†o ${editableSelected.length} √¥ v√† c·∫≠p nh·∫≠t ${rowsToSend.length} ƒë∆°n h√†ng.`, 'success', 3000); } } updateSelectionSummary(); return; } } const tableRows = Array.from(document.getElementById('tableBody').rows); let startRowIndex = tableRows.findIndex(row => row.rowIndex === pasteAnchorCell.parentElement.rowIndex); let startColIndex = pasteAnchorCell.cellIndex; if (startRowIndex < 0 || startColIndex < 0) return; const changesForBatchUpdate = new Map(); isPasting = true; pastedRows.forEach((rowData, i) => { const targetRow = tableRows[startRowIndex + i]; if (!targetRow) return; const orderId = targetRow.dataset.orderId; if (!orderId) return; if (!changesForBatchUpdate.has(orderId)) { changesForBatchUpdate.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId }); } rowData.forEach((cellData, j) => { const targetCell = targetRow.cells[startColIndex + j]; if (targetCell && targetCell.classList.contains('editable')) { const colName = displayColumns[startColIndex + j]; const dataKey = columnMapping[colName] || colName; setCellValue(targetCell, cellData); let valueForApi = cellData; if (colName === "Ng√†y ƒë√≥ng h√†ng") { valueForApi = parseDateToISO(cellData); } changesForBatchUpdate.get(orderId)[dataKey] = valueForApi; } }); }); isPasting = false; const rowsToSend = Array.from(changesForBatchUpdate.values()); if (rowsToSend.length > 0) { batchUpdatePastedData(rowsToSend); if (!hasTrackingChanges(rowsToSend)) { showCustomAlert(`ƒê√£ d√°n ${pastedRows.length} d√≤ng d·ªØ li·ªáu v√† c·∫≠p nh·∫≠t ${rowsToSend.length} ƒë∆°n h√†ng.`, 'success', 3000); } } updateSelectionSummary(); }); document.addEventListener('keydown', e => { const activeEl = document.activeElement; if (activeEl && (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) || activeEl.isContentEditable)) { return; } if (e.key === 'Delete' || e.key === 'Backspace') { const editableSelected = document.querySelectorAll('td.cell-selected.editable'); if (editableSelected.length > 0) { e.preventDefault(); const changesForBatchUpdate = new Map(); editableSelected.forEach(cell => { const targetRow = cell.parentElement; const orderId = targetRow.dataset.orderId; if (!orderId) return; const colIndex = cell.cellIndex; const colName = displayColumns[colIndex]; const dataKey = columnMapping[colName] || colName; if (!editableCols.includes(colName)) return; setCellValue(cell, ''); if (!changesForBatchUpdate.has(orderId)) { changesForBatchUpdate.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId }); } changesForBatchUpdate.get(orderId)[dataKey] = ''; }); const rowsToSend = Array.from(changesForBatchUpdate.values()); if (rowsToSend.length > 0) { batchUpdatePastedData(rowsToSend); if (!hasTrackingChanges(rowsToSend) && editableSelected.length > 1) { showCustomAlert(`ƒê√£ x√≥a n·ªôi dung c·ªßa ${editableSelected.length} √¥ v√† c·∫≠p nh·∫≠t ${rowsToSend.length} ƒë∆°n h√†ng.`, 'success', 2000); } } updateSelectionSummary(); } } }); }
        function showSyncPopover() { const popover = document.getElementById('syncPopover'); const body = document.getElementById('popoverBody'); body.innerHTML = ''; const createTableHTML = (changesMap) => { let html = '<table class="popover-table"><thead><tr><th>M√£ ƒê∆°n H√†ng</th><th>C·ªôt Thay ƒê·ªïi</th><th>Gi√° Tr·ªã</th></tr></thead><tbody>'; changesMap.forEach((colChanges, orderId) => { colChanges.forEach((changeInfo, colName) => { html += `<tr><td>${orderId}</td><td>${colName}</td><td><span class="old-value">${changeInfo.originalValue || '(tr·ªëng)'}</span><span class="new-value">${changeInfo.newValue || '(tr·ªëng)'}</span></td></tr>`; }); }); html += '</tbody></table>'; return html; }; body.innerHTML += '<h5>D·ªØ li·ªáu t·ª´ phi√™n tr∆∞·ªõc (ch∆∞a ƒë∆∞·ª£c ƒë·ªìng b·ªô)</h5>'; if (state.legacyChanges.size > 0) { body.innerHTML += createTableHTML(state.legacyChanges); } else { body.innerHTML += '<p class="no-changes">Kh√¥ng c√≥.</p>'; } body.innerHTML += '<h5 style="margin-top: 20px;">Thay ƒë·ªïi trong phi√™n n√†y</h5>'; if (state.pendingChanges.size > 0) { body.innerHTML += createTableHTML(state.pendingChanges); } else { body.innerHTML += '<p class="no-changes">Kh√¥ng c√≥.</p>'; } popover.style.display = 'flex'; }
        function downloadAsExcel() { const allFilteredData = (function () { const mergedData = state.allData.map(originalRow => { const orderId = originalRow[PRIMARY_KEY_COLUMN]; const changes = state.pendingChanges.get(orderId) || state.legacyChanges.get(orderId); if (changes) { const changeObject = {}; changes.forEach((changeInfo, key) => { changeObject[key] = changeInfo.newValue; }); return { ...originalRow, ...changeObject }; } return originalRow; }); let dataToExport = filterByCarrier(mergedData); const market = document.getElementById('filterMarket').value; if (market) { dataToExport = dataToExport.filter(row => row["Khu v·ª±c"] === market); } const product = document.getElementById('filterProduct').value; if (product) { dataToExport = dataToExport.filter(row => row["M·∫∑t h√†ng"] === product); } const dateFrom = document.getElementById('filterDateFrom').value; if (dateFrom) { const from = new Date(dateFrom); from.setHours(0, 0, 0, 0); dataToExport = dataToExport.filter(row => row["Ng√†y l√™n ƒë∆°n"] && new Date(row["Ng√†y l√™n ƒë∆°n"]) >= from); } const dateTo = document.getElementById('filterDateTo').value; if (dateTo) { const to = new Date(dateTo); to.setHours(23, 59, 59, 999); dataToExport = dataToExport.filter(row => row["Ng√†y l√™n ƒë∆°n"] && new Date(row["Ng√†y l√™n ƒë∆°n"]) <= to); } if (state.activeTeam === 'mgt_noi_bo') { if (state.mgtNoiBoOrder.length > 0) { const orderedIds = new Set(state.mgtNoiBoOrder); dataToExport = dataToExport.filter(row => orderedIds.has(row["M√£ ƒë∆°n h√†ng"])); const orderIndexMap = new Map(state.mgtNoiBoOrder.map((id, index) => [id, index])); dataToExport.sort((a, b) => orderIndexMap.get(a[PRIMARY_KEY_COLUMN]) - orderIndexMap.get(b[PRIMARY_KEY_COLUMN])); } } else if (state.activeTeam !== 'all') { dataToExport = dataToExport.filter(row => row[TEAM_COLUMN_NAME] === state.activeTeam); } const trackingIncludeRaw = state.filterValues['tracking_include'] || ''; const trackingExcludeRaw = state.filterValues['tracking_exclude'] || ''; const otherColumnFilters = Object.entries(state.filterValues).filter(([key, val]) => !key.startsWith('tracking_') && ((Array.isArray(val) && val.length > 0) || (typeof val === 'string' && val.trim() !== ''))); if (otherColumnFilters.length > 0) { dataToExport = dataToExport.filter(row => { return otherColumnFilters.every(([col, filterValue]) => { const dataKey = columnMapping[col] || col; const cellValue = (row[dataKey] ?? row[col] ?? '').toString().trim(); if (Array.isArray(filterValue)) { const EMPTY_OPTION_VALUE = '__EMPTY__'; if (filterValue.length === 0) return true; const hasEmptyFilter = filterValue.includes(EMPTY_OPTION_VALUE); if (cellValue === '' && hasEmptyFilter) return true; return filterValue.includes(cellValue); } else { return cellValue.toLowerCase().includes(filterValue.toLowerCase()); } }); }); } if (trackingIncludeRaw || trackingExcludeRaw) { const lowerInclude = trackingIncludeRaw.toLowerCase(); const lowerExclude = trackingExcludeRaw.toLowerCase(); dataToExport = dataToExport.filter(row => { const cellValue = String(row['M√£ Tracking'] || ''); const lowerCellValue = cellValue.toLowerCase(); if (lowerExclude && lowerCellValue.includes(lowerExclude)) { return false; } if (lowerInclude) { if (lowerInclude.includes('\n')) { const codes = new Set(trackingIncludeRaw.split('\n').map(t => t.trim()).filter(Boolean)); if (!codes.has(cellValue.trim())) return false; } else { if (!lowerCellValue.includes(lowerInclude)) return false; } } return true; }); } if (state.showDuplicateTrackingOrders) { const trackingCounts = new Map(); dataToExport.forEach(row => { const trackingCode = String(row["M√£ Tracking"] || '').trim(); if (trackingCode) { trackingCounts.set(trackingCode, (trackingCounts.get(trackingCode) || 0) + 1); } }); const duplicateTrackings = new Set(); for (const [code, count] of trackingCounts.entries()) { if (count > 1) { duplicateTrackings.add(code); } } dataToExport = dataToExport.filter(row => duplicateTrackings.has(String(row["M√£ Tracking"] || '').trim())); } else { dataToExport = dataToExport.filter(row => { const trackingCode = String(row["M√£ Tracking"] || row["M√£_Tracking"] || ''); return state.showTrackingOrders ? trackingCode.trim() !== '' : !trackingCode.trim(); }); } if (state.activeTeam !== 'mgt_noi_bo') { dataToExport.sort((a, b) => { const parseDate = (val) => val ? new Date(val) : null; const dateA = parseDate(a['Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2']); const dateB = parseDate(b['Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2']); if (dateA && dateB) return dateA - dateB; if (dateA) return -1; if (dateB) return 1; return (a[PRIMARY_KEY_COLUMN] || '').localeCompare(b[PRIMARY_KEY_COLUMN] || ''); }); } return dataToExport; })(); if (allFilteredData.length === 0) { showCustomAlert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ t·∫£i v·ªÅ.", 'info'); return; } const sanitizeCsvCell = (cell, colName) => { if (cell === null || cell === undefined) return ''; let str = String(cell); if ((colName === "M√£ Tracking" || colName === "Phone*") && str) { return `="${str.replace(/"/g, '""')}"`; } if (str.includes(',') || str.includes('"') || str.includes('\n')) { str = str.replace(/"/g, '""'); return `"${str}"`; } return str; }; const headers = displayColumns.map(col => sanitizeCsvCell(col, col)).join(','); const rows = allFilteredData.map(row => { return displayColumns.map(col => { const dataKey = columnMapping[col] || col; let value = row[dataKey] ?? row[col] ?? row[col.replace(/ /g, '_')] ?? ''; if (["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"].includes(col)) { value = formatDate(value); } return sanitizeCsvCell(value, col); }).join(','); }).join('\n'); const BOM = '\uFEFF'; const csvContent = BOM + headers + '\n' + rows; const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const link = document.createElement("a"); if (link.download !== undefined) { const url = URL.createObjectURL(blob); const today = new Date(); const dateStr = `${today.getFullYear()}${(today.getMonth() + 1).toString().padStart(2, '0')}${today.getDate().toString().padStart(2, '0')}`; link.setAttribute("href", url); link.setAttribute("download", `BaoCaoDonHang_MGT_${dateStr}.csv`); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); } }

        document.addEventListener('DOMContentLoaded', () => {
            setupControls();
            setupInteractionHandlers();
            const storedFilters = localStorage.getItem('speegoColumnFilters');
            if (storedFilters) {
                try { state.filterValues = JSON.parse(storedFilters); } catch (e) { state.filterValues = {}; }
            }
            state.rowsPerPage = parseInt(document.getElementById('rowsPerPageSelect').value, 10);
            
            // Add global click listener to close dropdowns
            document.addEventListener('click', () => {
                document.querySelectorAll('.multiselect-dropdown.show').forEach(dropdown => dropdown.classList.remove('show'));
            });

            loadData();
        });
    </script>
</body>

</html>
